\documentclass[a4paper,11pt]{scrartcl}

\usepackage[english]{babel}
% uncomment or modify according to your operating system
% \usepackage[applemac]{inputenc} % european characters can be used (Mac OS)
%\usepackage[latin1]{inputenc} 
%\usepackage{ucs} % fuer deutsche Sonderzeichen unter Linux
%\usepackage[utf8x]{inputenc} %fuer deutsche Sonderzeichen unter Linux
\usepackage[utf8]{inputenc} %fuer deutsche Sonderzeichen unter Windows
\usepackage[T1]{fontenc}
\usepackage{graphicx} 
\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{ifthen}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{cite}

\usepackage{float}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ %
  language=Matlab,                % the language of the code
  basicstyle=\small,              % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                   % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={end,sortrows}               % if you want to add more keywords to the set
}


% Abkuerzungen fuer haeufige Befehle wie z.B. griechische Buchstaben
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\La}{\mathcal{L}}
\newcommand{\de}{\delta}
\newcommand{\e}{\varepsilon}
\newcommand{\la}{\lambda} 
\newcommand{\p}{\varphi} 
\newcommand{\al}{\alpha} 
\newcommand{\be}{\beta} 
\newcommand{\om}{\omega}
\newcommand{\Om}{\Omega}
\newcommand{\ta}{\tau}
\newcommand{\g}{\gamma}
\newcommand{\HE}{\mathbb{H}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\vG}{\varGamma}
\newcommand{\s}{\sigma}

\begin{document}

\subject{194.076 Modeling and Simulation}
\title{Discrete Event Simulation Case Study: Dining Philosophers
Problem}

%  TODO: add names
%  TODO: add description of which parts did woh in the footnote as in the template!

\publishers{Supervisor: Madlen Martinek}
\author{Assylbek Tleules, 12432843 - Curriculum Number: UE 066 645 \footnote{TODO: ADD DESCRIPTION}\\
Arian Ahmad, 01529233 - Curriculum Number: UE 066 926 \footnote{TODO: ADD DESCRIPTION}\\
Hasan Hüseyin Günes, 12229237 - Curriculum Number: UE 066 645\footnote{TODO: ADD DESCRIPTION}\\
}

\maketitle
% TODO
\begin{abstract}
TODO: Brief Abstract
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Introduction}

When multiple processes or systems share a limited set of resources, several problems can occur. If the coordination is done poorly, the whole system can get stuck in a deadlock, where no further progress is possible. In addition, if the system cannot ensure a certain fairness level, individual components may experience very long waiting times compared to others, also called starvation. The Dining Philosophers problem\footnote{\url{https://en.wikipedia.org/wiki/Dining_philosophers_problem}} is a simple but realistic example of such situations. It helps to understand why these issues can occur and provides a useful basis for copmaring different methods that aim to prevent them. 

As shown in Figure~\ref{fig:diningphilosophers}, in the Dining Philosophers problem, philosophers sit around a table with one chopstick placed between each pair of neighboring philosophers. Over time, each philosopher repeats the cycle of thinking, being hungry and eating. To eat, a philosopher needs two chopsticks (the left and right one), while one chopstick can only be held by one philosopher at a time. Since neighboring philosophers share one chopstick, such conflicts can occur. Depending on the rule for picking up chopsticks, a situation could arise where every philosophers holds one chopstick and waits for the second one to become available. Another issue regarding the fairness could be that some philosophers may wait for much longer then others, when they want to eat.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.5\textwidth]{report/images/dining_philosophers_2.png}
 \caption{Dining philosophers sitting at a round table, each with a bowl of food and chopsticks.\protect\footnotemark}
 \label{fig:diningphilosophers}
\end{figure}
\footnotetext{\url{https://diningphilosophers.eu/}}

Based on a discrete event simulation (DES) model, this work aims to implement the Dining Philosophers system and analyze its behavior under different configurations and rules. First, the base concept without any additional methods is inspected. Then, methods are introduced to the concept, which aim to detect and prevent deadlocks and to reduce starvation cases. Finally, we consider further scenarios such as varying the number of philosophers and allowing rule violations by individual philosophers. The different settings are compared using the simulation outcomes.  

\section{Model}

TODO: do not forget to update requirements.txt after finishing implementation!

As already mentioned, a DES approach is used to realize this problem. The model is implemented in Python, and the source code is publicly available in a GitHub Repository\footnote{\url{https://github.com/tleules23/ModSim2025}}.

\subsection{General Modeling Approach}

describe in general how we modeled (which classes / entitites etc.)

+ f.e. explain 1 time unit = 1 min etc.\\

The DES contains three core components: entities, events and event schedule. The entities are philosophers and chopsticks. Philosophers can be in the states \verb|THINKING|, \verb|HUNGRY| or \verb|EATING|, whereas the chopsticks form the shared resources that can be acquired and released. Events are used to illustrate changes and resource interactions, such as a philosopher finish thinking and becoming hungry or attempting to acquire chopsticks. The event schedule is implemented as a time-ordered priority queue and defines the timeline of the events. The simulation time progress is given by repeatedly processing the next event in time-oriented order.

The initial setup looks as follows: five philosophers, each starting in the \verb|THINKING| state, are seating around a round table, with one chopstick placed between neighboring philosophers (= five chopsticks). Random delays are introduced every time a philosophers starts thinking or eating, to model asynchronous, more realistic behavior, specifically for thinking durations, acquisition retries when chopsticks are unavailable, and eating durations. These delays are mainly sampled from exponential distributions, while in the case, where additional scenarios are inspected, these distributions are varied (see Section~\ref{scenario_variations}).

The default delay distributions sampled from are as follows: We model thinking times using an exponential distribution with mean 5, and eating times using an exponential distribution with mean 3. Exponential distributions are a standard choice for stochastic durations, since they are non-negative and capture memoryless, asynchronous timing. The selected means reflect our assumption that philosophers typically spend more time on their main hobby, thinking, than eating. Unless stated otherwise, one time unit corresponds to one minute. Most simulation runs use a time horizon of 120 time units.

For the thinking times, we chose an exponential distribution with mean 5 and the eating time also en exponential distribution with mean 3. Generally, one time units in our case represents one minute. In most cases, one simulation has a duration of 120 time units.



\subsection{Base Model}

1. Describe basic model, what happens if deadlock etc., like just describing the setting you chose in task 1

\subsection{Deadlock Detection / Prevention}

2. explain Deadlock -> describe our Deadlock Detection / Prevention Concepts

\subsection{Starvation Avoidance}

Deadlocks are not the only issues that can occur during the simulation runs. Because of the mostly stochastic nature of the dining philosopher problem, given by the unordered sequence of chopstick acquisitions by the philosophers, it is possible that each participant in the simulation run is waiting indefinitely for his turn to eat. A fitting example would be the case where both neighbors of the same philosopher always take the chopsticks first. Long enough waiting times can lead to starvation, which for the dining philosophers problem is considered as a failed run if even one philosopher starves. In our model, starvation does not directly imply death or termination; it refers to unfair scheduling where a philosopher may wait indefinitely while others continue to eat. In the current baseline implementation biased anyone can attempt to grab free chopsticks and fast or lucky philosophers may finish thinking earlier, retry more aggressively or acquire chopsticks repeatedly. 

This possibility of indefinite waiting times requires the addition of a mechanism that ensures fairness between the members for acquiring the chopsticks.

\subsubsection{Fairness Mechanism}

In order to combat starvation, the model is using an aging-based scheduling strategy in which hungry philosophers, stored in a queue, are dynamically prioritized by the time elapsed since their last eating event. By default, each philosopher keeps track of their most recent eating event time. Before every chopstick acquisition attempt the model calculates the passed time since the last eating event for every hungry philosopher:

\[priority = current\_time - last\_ate\_time\]

Based on that, the hungry philosopher with the largest elapsed time since the last eating event is considered the highest-priority candidate. For the model, this means that only this philosopher is allowed to acquire the chopsticks for eating, and other hungry philosophers must wait until they become the highest-priority candidate. After finishing eating, the philosopher's last eating time is updated to the current simulation time and they are removed from the hungry queue. This ensures that hungry philosophers who have waited the longest don't indefinitely have to wait for their order to eat and starve out. The additional fairness in the model, indicated by a lower deviation of the eating counts between philosophers, comes with a set of trade-offs, specifically the longer overall waiting times and the lower average and total eating counts due the non-arbitrary selection for the chopstick acquisition.
\\

\begin{lstlisting}[
 basicstyle=\footnotesize,
 frame=single,
 language=c++,
 numbers=left,
 caption={Priority-based starvation avoidance (pseudocode).},
 label=lst:starvation_avoidance
]
When a philosopher becomes HUNGRY:
    add philosopher to hungry_queue

When chopstick acquisition is attempted:
    select philosopher p from hungry_queue
        with maximum (current_time − p.last_ate_time)

    if p can acquire both chopsticks:
        p eats
        update p.last_ate_time
        remove p from hungry_queue
    else:
        schedule a retry for p
\end{lstlisting}


\subsection{Scenario Variations}\label{scenario_variations}

After defining the base model and the different mechanisms to cope with issues like deadlocks and starvation, we extend the analysis beyond the standard setting to inspect differences in outcomes under more challenging conditions. Applied extensions are described below.

We will vary the number of philosophers and look at how the results are changed, especially in terms of deadlock runs.

Next, we will vary stochastic characteristics of thinking times and eating times. In the context of thinking times, we want to look at two different uniform distributions: $unif(2,30)$ and $unif(2,4)$. We chose these distributions with the corresponding limits to ensure that we inspect a higher and lower scale for thinking durations.

In addition, we will also look at two different configurations of a a truncated normal distribution for eating times: 

\begin{itemize}
    \item $norm(8,3)$ with truncated values resulting in range [1,16]
    \item $norm(15,3)$ with truncated values resulting in range [1,30]
\end{itemize}

We chose the normal distribution here, since it seems to also be realistic, when it comes to eating times. In most cases, the eating time should not change that much on average, while there could also be cases, where the philosopher just takes a snack, or eats more than normally. We think, the normal distribution covers such cases. 

As an extension of the base rules, we introduce selfish philosophers to the whole concept. In this context, selfish means that a philosopher may not follow some of the ground rules of the system. Some of the characteristics of the selfish philosophers are listed below.

\begin{itemize}
    \item Ignoring the Timeout strategy, used for Deadlock Prevention
    \item Ignoring the Priority Ordering Strategy and just deciding randomly on which chopstick to take first
    \item No immediately dropping of chopsticks after finishing eating
\end{itemize}

Apart from that, we will again extend the basic rules and introduce conspirator philosophers. Conspirator philosophers are two philosophers, who try to block the one victim philosopher in between them, by keeping the victim's required chopsticks unavailable as often as possible. The conspirator philosophers will have the following characteristics:

\begin{itemize}
    \item Conspiracy is active while the victim is hungry. Otherwise, the conspirators are acting normally.
    \item Targeted acquisition: When the victim is hungry, each conspirator prioritizes the victim-critical chopstick, which the corresponding conspirator can acquire.
    \item Targeted holding: After finishing eating, a conspirator keeps holding the victim-critical (target) chopstick for an additional time.
    \item Conspirators retry faster when the victim is hungry, whereas the victim retries slower (simulating the case that f.e. the conspirators block him from retrying fast)    
\end{itemize}


\subsection{Evaluation Methodology}

In order to draw reliable conclusions, we do not rely on a single simulation run. For this reason, all simulations are done using a Monte Carlo Simulation. Depending on the scenario and parameter setting, each configuration is repeated between 50 and 100 times.

The evaluation is primarily based on summary statistics across runs, including the mean and standard deviation of measured performance and fairness metrics. For instance, the total number of eating events, the average number of eats per philosopher, as well as dispersion measures such as the minimum and maximum number of eats across philosophers are reported. Listing~\ref{lst:reportoutput} shows an example report generated from a Monte Carlo simulation (using same initial and further seeds). The focus of this Listing is on the structure of the reported metrics rather than on the specific numerical values.

\begin{lstlisting}[language={},keywordstyle=\color{black},commentstyle=\color{black},stringstyle=\color{black},caption={Example Report Output},
 label=lst:reportoutput]  
Runs: 100
Avg total eats: 47.96 +/- 6.62
Avg eats/philosopher: 9.59 +/- 1.32
Avg min/max eats: 7.51 / 11.79
Avg Gini (fairness): 0.088
Deadlock runs: 17/100
Avg first deadlock time: 76.99
Per-philosopher avg eats: [9.34, 9.54, 9.61, 9.75, 9.72]
Per-philosopher std eats: [2.11, 2.35, 2.04, 2.14, 1.91]
Per-philosopher avg thinking time: [49.74, 48.37, 48.97, 50.78, 49.28]
Per-philosopher avg hungry time:   [43.5, 43.47, 41.51, 41.06, 43.68]
Per-philosopher avg eating time:   [26.76, 28.16, 29.53, 28.16, 27.04]
Per-philosopher std thinking time: [12.37, 11.51, 12.69, 11.14, 12.09]
Per-philosopher std hungry time:   [11.61, 12.65, 12.81, 12.0, 11.4]
Per-philosopher std eating time:   [7.54, 8.03, 8.26, 8.34, 7.52]
Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]
\end{lstlisting}    

To monitor simulation progress and to enable debugging before running large Monte Carlo batches, we use logging during individual runs. Listing~\ref{lst:logging} illustrates a short example from the event log of an individual simulation run. 

\begin{lstlisting}[language={},keywordstyle=\color{black},commentstyle=\color{black},stringstyle=\color{black},caption={Snippet of an Example Simulation Logging},
 label=lst:logging]  
[t=0.27] Philosopher 0 is now HUNGRY
[t=0.38] Philosopher 0 is now EATING (count: 1)
[t=0.46] Philosopher 1 is now HUNGRY
[t=0.57] Philosopher 3 is now HUNGRY
[t=1.01] Philosopher 3 is now EATING (count: 1)
\end{lstlisting}  


\subsection{Implementation}

maybe talk about how we implemented it in general + some details maybe


Implementation should be distinguished from the conceptual modelling (see Section \ref{sec:modelling}) and described in a separate section. Keep it brief \textbf{do not} put the whole source-code into the documentation. If there are important snippets, you may use e.g. \verb|\lstinputlisting|.

 \lstinputlisting[
 language=Matlab,
 caption={Function polar2cartesian.},
 label={SRC:polar2cartesian}]{./code/BeispielCode.m}

Listing \ref{SRC:polar2cartesian} shows the source-code of \verb|polar2cartesian| in MATLAB. 
 
Source code without file can be included via:
\begin{lstlisting}[
 basicstyle=\footnotesize, % the size of the fonts that are used for the code
 frame=single,          
 language=c++,
 numbers=left,             % where to put the line-numbers
 escapeinside={//*}{*//},  % for line labeling
 caption={Definition der Klasse \texttt{InOutputVector}.},
 label=src:InOutputVector_defs]  
 class InOutputVector:public std::vector<InOutput> {
   public:
     int untreated_entry_changes;
     
     InOutputVector() {            //* \label{lnbr:InOutput_constructor} *//
       untreated_entry_changes = 0;
     }    
     void setAt(int c,double val,double t) {
       if(true==(*this)[c].already_treated) {
         untreated_entry_changes++;
       } 
       (*this)[c].set(val,t);
     }
     double* treatAt(int c,double val) {
       if(false==(*this)[c].already_treated) {
         untreated_entry_changes--;
       }
       return((*this)[c].treat());
     }
     void treatAll() {
       for(int i=0; i<this->size(); i++){
         (*this)[i].already_treated = true;
       }
       untreated_entry_changes=0;
     }
 };
\end{lstlisting}    

In row \ref{lnbr:InOutput_constructor} in Listing \ref{src:InOutputVector_defs} we find the constructor of class
\verb|InOutputVector|.

\section{Simulation Results}

Talking about results (in a storytelling way, so beginning with basic model, then extending with deadlock detection and so on, as in the notebook) + of course showing some plots

We document the results of the simulation as far as possible without potentially subjective interpretation. This is usually done with the help of plots.

\subsection{Base Model}

\subsection{Deadlock Detection / Prevention}

\subsection{Starvation Avoidance}

In the following, the impact of the starvation avoidance mechanism is investigated on the simulation runs using Monte Carlo simulation. A model using priority ordering is used as the baseline for comparing the system with and without starvation avoidance. Both of the model configurations are executed over 50 independent runs with identical parameters and the performance metrics are collected for every philosopher in each turn.

The following boxplots summarize the resulting distributions of four key metrics, namely eating frequency, total hungry time, maximum hungry time per run, and fairness measured as the standard deviation of eating counts.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{report/images/Task 4/eat_counts_boxplot.png}
    \caption{Eat counts across all philosophers and runs}
    \label{fig:eat-counts}
\end{figure}

\noindent
The boxplot above illustrates, the eat-count distribution reflects system throughput. With starvation avoidance enabled, the median eat count decreases and the distribution becomes more scattered. This is caused by the priority-based mechanism, which allows only the most-starved philosopher to attempt chopstick acquisition at a time, reducing parallelism. As a result, throughput is traded for improved control over starvation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{report/images/Task 4/hungry_times_boxplot.png}
    \caption{Eat counts across all philosophers and runs}
    \label{fig:eat-counts}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{report/images/Task 4/max_hungry_time.png}
    \caption{Eat counts across all philosophers and runs}
    \label{fig:eat-counts}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{report/images/Task 4/hungry_times_boxplot.png}
    \caption{Eat counts across all philosophers and runs}
    \label{fig:eat-counts}
\end{figure}


\subsection{Scneario Variations}

After analyzing deadlock and starvation behavior under the standard configuration, we now turn to additional scenario variations. In this part, each simulation is run for 800 time units and execute 100 MC runs. Unless stated otherwise, we use the base model with deadlock prevention enabled, but without the starvation avoidance mechanism.

\subsubsection{Varying Number of Philosophers}

First, we increase the number of philosophers (thus automatically also number of chopsticks) to 10, and compare simulation outcomes for the left-first (LF), priority ordering (PO) and timeout (TO) strategies. For the TO strategy, the timeout duration is set to 2 time units, if not stated otherwise.

%% results for this part %%

To see how the results change, we also set the number of philosophers to three and re-run with the same configurations.

%% results for this part %%

For the next part, we will inspect results with number of philosophers set to five, as in the standard model.

\subsubsection{Varying Thinking Time}

Now, we want to vary the thinking time. For this reason, we want to look at two different uniform distributions: $unif(2,30)$ and $unif(2,4)$. 

%% results for this part %%

%% analysis of reuslts %%

Since we want to get cases, where the deadlock possibility is high enough, we will set the distribution for the thinking times to $unif(0.3,3)$ for the remaining part of this section.

\subsubsection{Varying Eating Time}

As already mentioned, we will vary between two different configurations of a truncated normal distribution:

\begin{itemize}
    \item $norm(8,3)$ with truncated values resulting in range [1,16]
    \item $norm(15,3)$ with truncated values resulting in range [1,30]
\end{itemize}

With these configurations, we aim to see how the duration of the eating time with thinking times sampled from $unif(0.3,3)$ will impact the results. 

%% results for this part %%

\subsubsection{Selfish Philosophers}

Now, we will continue with the following default settings: Five philosophers, simulation run time set to 800, 100 excecuted MC runs, thinking time sampled from $unif(0.3,3$ and eating time sampled form $norm(8,3)$ (truncated: [1,16]).

\subsubsection{Conspirator Philosophers}

\section{Discussion}
\paragraph{Summary.} We tell what we told, and summarise that we showed some important \LaTeX commands for scientific writing and displayed some dummy simulation results.
\paragraph{Result Interpretation}
We interpret the results and put them in contrast with each other and the real system. 
\paragraph{Conclusion.} We conclude that writing a proper project documentation is not so hard and hope you have fun doing it yourself. 
\paragraph{Outlook.} However, we understand that further research might be necessary.
\newpage

\bibliographystyle{plain}
\bibliography{references}

\appendix
\section{Appendix}
\subsection{Not Quite Relevant Enough}
Some stuff which is not quite important enough for the main text.
\end{document}