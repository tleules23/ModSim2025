{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Discrete Event Simulation: Dining Philosophers\n",
    "\n",
    "\n",
    "\n",
    "**Task overview**\n",
    "- 5 philosophers sitting around round table\n",
    "- 5 chopsticks (one between each pair of philosophers)\n",
    "- Each philosopher needs 2 chopsticks to eat\n",
    "- States: Thinking -> Hungry -> Eating -> Thinking\n",
    "\n",
    "**Tasks implemented:**\n",
    "1. Basic simulation (100 time units)\n",
    "2. Deadlock detection\n",
    "3. Deadlock prevention (priority ordering + timeout strategies)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 206,
   "metadata": {},
   "outputs": [],
   "source": [
    "import heapq\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from dataclasses import dataclass, field\n",
    "from typing import List, Optional, Tuple\n",
    "from enum import Enum\n",
    "from collections import deque\n",
    "\n",
    "from copy import deepcopy\n",
    "\n",
    "random.seed(54)\n",
    "np.random.seed(54)\n",
    "\n",
    "sns.set_style(\"whitegrid\")\n",
    "plt.rcParams['figure.figsize'] = (12, 6)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Core Classes and Data Structures"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 232,
   "metadata": {},
   "outputs": [],
   "source": [
    "class PhilosopherState(Enum):\n",
    "    \"\"\"States philosopher can be in\"\"\"\n",
    "    THINKING = \"thinking\"\n",
    "    HUNGRY = \"hungry\"\n",
    "    EATING = \"eating\"\n",
    "\n",
    "\n",
    "class EventType(Enum):\n",
    "    \"\"\"Types of events in the simulation\"\"\"\n",
    "    FINISH_THINKING = \"finish_thinking\"\n",
    "    TRY_ACQUIRE_CHOPSTICKS = \"try_acquire_chopsticks\"\n",
    "    FINISH_EATING = \"finish_eating\"\n",
    "    TIMEOUT_RELEASE = \"timeout_release\"\n",
    "\n",
    "\n",
    "@dataclass(order=True)\n",
    "class Event:\n",
    "    \"\"\"Event in the discrete event simulation\"\"\"\n",
    "    time: float\n",
    "    event_type: EventType = field(compare=False)\n",
    "    philosopher_id: int = field(compare=False)\n",
    "    generation: int = field(compare=False, default=0)\n",
    "\n",
    "\n",
    "class Chopstick:\n",
    "    \"\"\"Represents a chopstick resource\"\"\"\n",
    "    def __init__(self, id: int):\n",
    "        self.id = id\n",
    "        self.held_by: Optional[int] = None\n",
    "\n",
    "    def is_available(self) -> bool:\n",
    "        return self.held_by is None\n",
    "\n",
    "    def acquire(self, philosopher_id: int) -> bool:\n",
    "        if self.is_available():\n",
    "            self.held_by = philosopher_id\n",
    "            return True\n",
    "        return False\n",
    "\n",
    "    def release(self):\n",
    "        self.held_by = None\n",
    "\n",
    "\n",
    "class Philosopher:\n",
    "    \"\"\"Represents a philosopher with state and behavior\"\"\"\n",
    "    def __init__(self, id: int, left: int, right: int, deadlock_prone: bool = False, \n",
    "                 unif_thinking_time: bool = False, think_unif_low: float = 2.0, think_unif_high: float = 30.0,\n",
    "                 gauss_eating_time: bool = False, eat_mean: float = 5.0, eat_sigma: float = 1.0, eat_gauss_low: float = 1.0, eat_gauss_high: float = 10.0):\n",
    "        self.id = id\n",
    "        self.state = PhilosopherState.THINKING\n",
    "        self.left_chopstick_id = left\n",
    "        self.right_chopstick_id = right\n",
    "        self.held_chopsticks: List[int] = []\n",
    "        self.eat_count = 0\n",
    "        self.total_thinking_time = 0.0\n",
    "        self.total_eating_time = 0.0\n",
    "        self.total_hungry_time = 0.0\n",
    "        self.last_state_change = 0.0\n",
    "        self.last_ate_time = 0.0\n",
    "        self.attempt_start_time = None\n",
    "        self.generation = 0\n",
    "        self.deadlock_prone = deadlock_prone\n",
    "\n",
    "        ## for task 5 ##\n",
    "        self.unif_thinking_time = unif_thinking_time\n",
    "        self.think_unif_low = think_unif_low\n",
    "        self.think_unif_high = think_unif_high\n",
    "\n",
    "        self.gauss_eating_time = gauss_eating_time\n",
    "        self.eat_mean = eat_mean\n",
    "        self.eat_sigma = eat_sigma\n",
    "        self.eat_gauss_low = eat_gauss_low\n",
    "        self.eat_gauss_high = eat_gauss_high\n",
    "\n",
    "    def get_thinking_time(self):\n",
    "        # return 0.0 if self.deadlock_prone else random.expovariate(1 / 5)\n",
    "        if self.deadlock_prone:\n",
    "            return 0.0\n",
    "        if self.unif_thinking_time:\n",
    "            return random.uniform(self.think_unif_low, self.think_unif_high)\n",
    "        return random.expovariate(1 / 5)\n",
    "\n",
    "    def get_eating_time(self):\n",
    "        def truncated_normal() -> float:\n",
    "            \"\"\"Sample N(mu, sigma) but reject values outside [lo, hi].\"\"\"\n",
    "            mu = self.eat_mean\n",
    "            sigma = self.eat_sigma\n",
    "            lo = self.eat_gauss_low\n",
    "            hi = self.eat_gauss_high\n",
    "\n",
    "            \n",
    "            if self.eat_sigma <= 0:\n",
    "                return max(lo, min(hi, mu))\n",
    "            while True:\n",
    "                x = random.gauss(mu, sigma)\n",
    "                if lo <= x <= hi:\n",
    "                    return x\n",
    "                \n",
    "        # return random.uniform(0.3, 0.8) if self.deadlock_prone else random.expovariate(1 / 3)\n",
    "        if self.deadlock_prone:\n",
    "            return random.uniform(0.3, 0.8)\n",
    "        if self.gauss_eating_time:\n",
    "            return truncated_normal()\n",
    "        return random.expovariate(1 / 3)\n",
    "\n",
    "    def get_retry_time(self):\n",
    "        return 0.2 if self.deadlock_prone else random.uniform(0.1, 0.5)\n",
    "\n",
    "    def update_state_time(self, now):\n",
    "        dt = now - self.last_state_change\n",
    "        if self.state == PhilosopherState.THINKING:\n",
    "            self.total_thinking_time += dt\n",
    "        elif self.state == PhilosopherState.HUNGRY:\n",
    "            self.total_hungry_time += dt\n",
    "        elif self.state == PhilosopherState.EATING:\n",
    "            self.total_eating_time += dt\n",
    "        self.last_state_change = now\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Simulation Engine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 251,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DiningPhilosophersSimulation:\n",
    "    \"\"\"Discrete event simulation of dining philosophers\"\"\"\n",
    "\n",
    "    def __init__(\n",
    "        self,\n",
    "        num_philosophers: int = 5,\n",
    "        deadlock_detection: bool = False,\n",
    "        prevention_strategy: str = \"none\",\n",
    "        starvation_prevention: bool = False,\n",
    "        timeout_duration: float = 2.0,\n",
    "        deadlock_prone: bool = False,\n",
    "        synchronized_start: bool = False,\n",
    "        force_deadlock_demo: bool = False,\n",
    "        halt_on_deadlock: bool = False\n",
    "    ):\n",
    "        \"\"\"\n",
    "        Initialize simulation\n",
    "\n",
    "        Args:\n",
    "            num_philosophers: number of philosophers (by default 5)\n",
    "            deadlock_detection: enable deadlock detection\n",
    "            prevention_strategy: 'none', 'priority', 'timeout'\n",
    "            timeout_duration: timeout for releasing chopsticks\n",
    "            deadlock_prone: use tighter think/eat times to increase contention\n",
    "            synchronized_start: have all philosophers start hungry at t=0 (for detection demo)\n",
    "            force_deadlock_demo: force everyone to hold left chopstick at t=0 (demo only)\n",
    "            halt_on_deadlock: if True, stop simulation on first deadlock (default: False)\n",
    "        \"\"\"\n",
    "        self.num_philosophers = num_philosophers\n",
    "        self.current_time = 0.0\n",
    "        self.event_queue = []\n",
    "        self.deadlock_detection = deadlock_detection\n",
    "        self.prevention_strategy = prevention_strategy\n",
    "        self.starvation_prevention = starvation_prevention\n",
    "        self.timeout_duration = timeout_duration\n",
    "        self.deadlock_prone = deadlock_prone\n",
    "        self.synchronized_start = synchronized_start\n",
    "        self.force_deadlock_demo = force_deadlock_demo\n",
    "        self.in_deadlock = False       # latch to avoid multiple counts per deadlock\n",
    "        self.halt_on_deadlock = halt_on_deadlock\n",
    "        self.halted = False            # track if simulation was halted\n",
    "\n",
    "        self.timeout_release_count = 0  # counts how often timeout release was triggered\n",
    "\n",
    "        # queues for starvation prevention\n",
    "        self.hungry_queue = deque()\n",
    "        self.in_queue = set()\n",
    "\n",
    "        # stats\n",
    "        self.deadlock_count = 0\n",
    "        self.deadlock_times = []\n",
    "\n",
    "        # persistent deadlock tracking (for timeout evaluation)\n",
    "        self.progress_time = 0.0  \n",
    "        self.deadlock_active = False\n",
    "        self.deadlock_start_time = None\n",
    "        self.persistent_deadlock_count = 0\n",
    "        self.persistent_deadlock_times = []\n",
    "        self.persistent_deadlock_window  = 3.0 * self.timeout_duration \n",
    "        self.persistent_deadlock_counted = False\n",
    "\n",
    "\n",
    "        self.event_log = []\n",
    "\n",
    "        # resources\n",
    "        self.chopsticks = [Chopstick(i) for i in range(num_philosophers)]\n",
    "\n",
    "        # philosophers\n",
    "        self.philosophers = []\n",
    "        for i in range(num_philosophers):\n",
    "            left = i\n",
    "            right = (i + 1) % num_philosophers\n",
    "            self.philosophers.append(Philosopher(i, left, right, deadlock_prone))\n",
    "\n",
    "        if synchronized_start:\n",
    "            # everyone hungry at t=0, no chopsticks yet\n",
    "            for phil in self.philosophers:\n",
    "                phil.state = PhilosopherState.HUNGRY\n",
    "                if self.starvation_prevention and phil.id not in self.in_queue:\n",
    "                    self.hungry_queue.append(phil.id)\n",
    "                    self.in_queue.add(phil.id)\n",
    "                phil.last_state_change = 0.0\n",
    "                self.schedule_event(Event(0.0, EventType.TRY_ACQUIRE_CHOPSTICKS, phil.id, phil.generation))\n",
    "        else:\n",
    "            # Normal initialization: everyone starts thinking\n",
    "            for phil in self.philosophers:\n",
    "                thinking_time = phil.get_thinking_time()\n",
    "                self.schedule_event(Event(thinking_time, EventType.FINISH_THINKING, phil.id))\n",
    "\n",
    "        # Optional demo: force immediate circular wait (everyone holds left)\n",
    "        if force_deadlock_demo:\n",
    "            for phil in self.philosophers:\n",
    "                phil.state = PhilosopherState.HUNGRY\n",
    "                if self.starvation_prevention and phil.id not in self.in_queue:\n",
    "                    self.hungry_queue.append(phil.id)\n",
    "                    self.in_queue.add(phil.id)\n",
    "                phil.held_chopsticks = [phil.left_chopstick_id]\n",
    "                self.chopsticks[phil.left_chopstick_id].held_by = phil.id\n",
    "                phil.last_state_change = 0.0\n",
    "                self.schedule_event(Event(0.0, EventType.TRY_ACQUIRE_CHOPSTICKS, phil.id, phil.generation))\n",
    "\n",
    "    def schedule_event(self, event: Event):\n",
    "        \"\"\"Add event to priority queue\"\"\"\n",
    "        heapq.heappush(self.event_queue, event)\n",
    "\n",
    "    def log_event(self, description: str):\n",
    "        \"\"\"Log simulation event\"\"\"\n",
    "        self.event_log.append({\n",
    "            'time': self.current_time,\n",
    "            'description': description\n",
    "        })\n",
    "\n",
    "    def get_chopstick_order(self, philosopher: Philosopher) -> Tuple[int, int]:\n",
    "        \"\"\"Get chopstick acquisition order based on prevention strategy\"\"\"\n",
    "        left = philosopher.left_chopstick_id\n",
    "        right = philosopher.right_chopstick_id\n",
    "        if self.prevention_strategy == \"priority\":\n",
    "            return (min(left, right), max(left, right))\n",
    "        return (left, right)\n",
    "\n",
    "    def _cleanup_hungry_queue(self):\n",
    "        while self.hungry_queue and self.philosophers[self.hungry_queue[0]].state != PhilosopherState.HUNGRY:\n",
    "            pid = self.hungry_queue.popleft()\n",
    "            self.in_queue.discard(pid)\n",
    "\n",
    "    def _pick_starvation_priority(self) -> Optional[int]:\n",
    "        if not self.hungry_queue:\n",
    "            return None\n",
    "        best_id = None\n",
    "        best_score = None\n",
    "        for pid in self.hungry_queue:\n",
    "            p = self.philosophers[pid]\n",
    "            if p.state != PhilosopherState.HUNGRY:\n",
    "                continue\n",
    "            score = self.current_time - p.last_ate_time\n",
    "            if best_id is None or score > best_score or (score == best_score and pid < best_id):\n",
    "                best_id = pid\n",
    "                best_score = score\n",
    "        return best_id\n",
    "\n",
    "    def kick_front(self):\n",
    "        if not self.starvation_prevention:\n",
    "            return\n",
    "        self._cleanup_hungry_queue()\n",
    "        chosen_id = self._pick_starvation_priority()\n",
    "        if chosen_id is None:\n",
    "            return\n",
    "        chosen = self.philosophers[chosen_id]\n",
    "        self.schedule_event(Event(self.current_time, EventType.TRY_ACQUIRE_CHOPSTICKS, chosen_id, chosen.generation))\n",
    "\n",
    "    def try_acquire_chopsticks(self, philosopher: Philosopher) -> bool:\n",
    "        \"\"\"Two-phase acquire: take first chopstick, then try for second later\"\"\"\n",
    "        first_id, second_id = self.get_chopstick_order(philosopher)\n",
    "        first_chopstick = self.chopsticks[first_id]\n",
    "        second_chopstick = self.chopsticks[second_id]\n",
    "\n",
    "        has_first = first_id in philosopher.held_chopsticks\n",
    "        has_second = second_id in philosopher.held_chopsticks\n",
    "\n",
    "        # Step 1: grab the first if not already holding it\n",
    "        if not has_first:\n",
    "            if first_chopstick.acquire(philosopher.id):\n",
    "                philosopher.held_chopsticks.append(first_id)\n",
    "            else:\n",
    "                return False\n",
    "            # give everyone time to grab their first chopstick\n",
    "            return False\n",
    "\n",
    "        # Step 2: try to grab the second\n",
    "        if not has_second:\n",
    "            if second_chopstick.acquire(philosopher.id):\n",
    "                philosopher.held_chopsticks.append(second_id)\n",
    "                return True\n",
    "            else:\n",
    "                if self.prevention_strategy == \"timeout\" and philosopher.attempt_start_time is None:\n",
    "                    philosopher.attempt_start_time = self.current_time\n",
    "                    self.schedule_event(Event(\n",
    "                        self.current_time + self.timeout_duration,\n",
    "                        EventType.TIMEOUT_RELEASE,\n",
    "                        philosopher.id,\n",
    "                        philosopher.generation\n",
    "                    ))\n",
    "                return False\n",
    "\n",
    "        # Already holding both\n",
    "        return True\n",
    "\n",
    "    def release_chopsticks(self, philosopher: Philosopher):\n",
    "        \"\"\"Release all held chopsticks\"\"\"\n",
    "        for chopstick_id in philosopher.held_chopsticks:\n",
    "            self.chopsticks[chopstick_id].release()\n",
    "        philosopher.held_chopsticks = []\n",
    "        philosopher.attempt_start_time = None\n",
    "        philosopher.generation += 1  # invalidate pending events for this philosopher\n",
    "\n",
    "    def check_deadlock(self) -> bool:\n",
    "        \"\"\"\n",
    "        Check if system is in deadlock.\n",
    "        Deadlock = all philosophers hungry AND each holds exactly one chopstick (circular wait).\n",
    "        This is a structural condition â€” detected immediately, no time delay needed.\n",
    "        \"\"\"\n",
    "        if not self.deadlock_detection:\n",
    "            return False\n",
    "\n",
    "        hungry_count = sum(1 for p in self.philosophers if p.state == PhilosopherState.HUNGRY)\n",
    "        if hungry_count == self.num_philosophers:\n",
    "            holding_one = sum(1 for p in self.philosophers if len(p.held_chopsticks) == 1)\n",
    "            if holding_one == self.num_philosophers:\n",
    "                return True  # circular wait confirmed\n",
    "        return False\n",
    "\n",
    "    def handle_finish_thinking(self, philosopher: Philosopher):\n",
    "        philosopher.update_state_time(self.current_time)\n",
    "        philosopher.state = PhilosopherState.HUNGRY\n",
    "\n",
    "        if self.starvation_prevention:\n",
    "            if philosopher.id not in self.in_queue:\n",
    "                self.hungry_queue.append(philosopher.id)\n",
    "                self.in_queue.add(philosopher.id)\n",
    "\n",
    "        self.log_event(f\"Philosopher {philosopher.id} is now HUNGRY\")\n",
    "        self.schedule_event(Event(self.current_time, EventType.TRY_ACQUIRE_CHOPSTICKS, philosopher.id, philosopher.generation))\n",
    "        self.kick_front()\n",
    "\n",
    "    def handle_try_acquire(self, philosopher: Philosopher):\n",
    "        if philosopher.state != PhilosopherState.HUNGRY:\n",
    "            return\n",
    "\n",
    "        success = self.try_acquire_chopsticks(philosopher)\n",
    "\n",
    "        if success:\n",
    "            philosopher.update_state_time(self.current_time)\n",
    "            philosopher.state = PhilosopherState.EATING\n",
<<<<<<< HEAD
    "            if self.starvation_prevention and philosopher.id in self.in_queue:\n",
    "                self.in_queue.discard(philosopher.id)\n",
    "                try:\n",
    "                    self.hungry_queue.remove(philosopher.id)\n",
    "                except ValueError:\n",
    "                    pass\n",
=======
    "\n",
    "            # progress happened (someone eats)\n",
    "            self.progress_time = self.current_time\n",
    "\n",
    "            # a new progress breaks any ongoing persistent-deadlock episode\n",
    "            # self.persistent_deadlock_counted = False\n",
    "\n",
    "\n",
    "            if self.starvation_prevention:\n",
    "                if self.hungry_queue and self.hungry_queue[0] == philosopher.id:\n",
    "                    self.hungry_queue.popleft()\n",
    "                    self.in_queue.discard(philosopher.id)\n",
    "                else:\n",
    "                    # safety: remove if present elsewhere (shouldn't happen)\n",
    "                    if philosopher.id in self.in_queue:\n",
    "                        self.in_queue.discard(philosopher.id)\n",
    "                        try:\n",
    "                            self.hungry_queue.remove(philosopher.id)\n",
    "                        except ValueError:\n",
    "                            pass\n",
>>>>>>> 7bf5bb1492ba0c354633602b3f7732f4e11c3923
    "            philosopher.eat_count += 1\n",
    "            philosopher.last_ate_time = self.current_time\n",
    "            self.in_deadlock = False  # clear latch on progress\n",
    "            self.log_event(f\"Philosopher {philosopher.id} is now EATING (count: {philosopher.eat_count})\")\n",
    "            eating_time = philosopher.get_eating_time()\n",
    "            self.schedule_event(Event(self.current_time + eating_time, EventType.FINISH_EATING, philosopher.id, philosopher.generation))\n",
    "        else:\n",
    "            retry_time = philosopher.get_retry_time()\n",
    "            self.schedule_event(Event(self.current_time + retry_time, EventType.TRY_ACQUIRE_CHOPSTICKS, philosopher.id, philosopher.generation))\n",
    "\n",
    "    def handle_finish_eating(self, philosopher: Philosopher):\n",
    "        philosopher.update_state_time(self.current_time)\n",
    "        self.release_chopsticks(philosopher)\n",
    "        philosopher.state = PhilosopherState.THINKING\n",
    "        self.in_deadlock = False  # clear latch on progress\n",
    "        self.log_event(f\"Philosopher {philosopher.id} is now THINKING\")\n",
    "        thinking_time = philosopher.get_thinking_time()\n",
    "        self.schedule_event(Event(self.current_time + thinking_time, EventType.FINISH_THINKING, philosopher.id))\n",
    "        self.kick_front()\n",
    "\n",
    "    def handle_timeout_release(self, philosopher: Philosopher):\n",
    "        if philosopher.state == PhilosopherState.HUNGRY and len(philosopher.held_chopsticks) > 0:\n",
    "            self.log_event(f\"Philosopher {philosopher.id} TIMEOUT - releasing chopsticks\")\n",
    "            self.release_chopsticks(philosopher)\n",
    "            self.timeout_release_count += 1\n",
    "            self.in_deadlock = False  # clear latch after forced release\n",
    "            retry_time = philosopher.get_retry_time()\n",
    "            self.schedule_event(Event(self.current_time + retry_time, EventType.TRY_ACQUIRE_CHOPSTICKS, philosopher.id, philosopher.generation))\n",
    "            self.kick_front()\n",
    "\n",
    "    def process_event(self, event: Event):\n",
    "        self.current_time = event.time\n",
    "        philosopher = self.philosophers[event.philosopher_id]\n",
    "\n",
    "        if event.event_type == EventType.FINISH_THINKING:\n",
    "            self.handle_finish_thinking(philosopher)\n",
    "\n",
    "        elif event.event_type == EventType.TRY_ACQUIRE_CHOPSTICKS:\n",
    "            if self.starvation_prevention:\n",
    "                self._cleanup_hungry_queue()\n",
    "                chosen_id = self._pick_starvation_priority()\n",
    "                if chosen_id is None:\n",
    "                    return\n",
    "                chosen = self.philosophers[chosen_id]\n",
    "                if event.philosopher_id != chosen_id:\n",
    "                    return\n",
    "                if event.generation != chosen.generation:\n",
    "                    return\n",
    "                self.handle_try_acquire(chosen)\n",
    "            else:\n",
    "                # Baseline: the philosopher tied to this event tries\n",
    "                if event.generation == philosopher.generation:  # ignore stale retries\n",
    "                    self.handle_try_acquire(philosopher)\n",
    "\n",
    "        elif event.event_type == EventType.FINISH_EATING:\n",
    "            if event.generation == philosopher.generation:\n",
    "                self.handle_finish_eating(philosopher)\n",
    "\n",
    "        elif event.event_type == EventType.TIMEOUT_RELEASE:\n",
    "            if event.generation == philosopher.generation:  # ignore stale timeouts\n",
    "                self.handle_timeout_release(philosopher)\n",
    "\n",
    "        # if self.check_deadlock():\n",
    "        #     if not self.in_deadlock:\n",
    "        #         self.in_deadlock = True\n",
    "        #         self.deadlock_count += 1\n",
    "        #         self.deadlock_times.append(self.current_time)\n",
    "        #         self.log_event(f\"DEADLOCK DETECTED! (occurrence #{self.deadlock_count})\")\n",
    "\n",
    "        #         # If halt_on_deadlock is enabled, mark as halted and stop\n",
    "        #         if self.halt_on_deadlock and self.prevention_strategy != \"timeout\":\n",
    "        #             self.halted = True\n",
    "        #             self.log_event(\"SIMULATION HALTED DUE TO DEADLOCK\")\n",
    "        #             return\n",
    "\n",
    "        #         # never apply the breaker when using timeout!!\n",
    "        #         if self.prevention_strategy != \"timeout\":\n",
    "\n",
    "        #             # Break deadlock: find the philosopher waiting longest,\n",
    "        #             # then release the neighbor who holds their needed chopstick.\n",
    "        #             # This lets the longest-waiting philosopher eat next.\n",
    "        #             longest_hungry = None\n",
    "        #             max_wait = -1.0\n",
    "        #             for p in self.philosophers:\n",
    "        #                 if p.state == PhilosopherState.HUNGRY:\n",
    "        #                     wait_time = self.current_time - p.last_state_change\n",
    "        #                     if wait_time > max_wait or (wait_time == max_wait and (longest_hungry is None or p.id < longest_hungry.id)):\n",
    "        #                         max_wait = wait_time\n",
    "        #                         longest_hungry = p\n",
    "\n",
    "        #             if longest_hungry:\n",
    "        #                 needed_chopstick_id = None\n",
    "        #                 for cid in (longest_hungry.left_chopstick_id, longest_hungry.right_chopstick_id):\n",
    "        #                     if cid not in longest_hungry.held_chopsticks:\n",
    "        #                         needed_chopstick_id = cid\n",
    "        #                         break\n",
    "\n",
    "        #                 if needed_chopstick_id is not None:\n",
    "        #                     holder_id = self.chopsticks[needed_chopstick_id].held_by\n",
    "        #                     if holder_id is not None:\n",
    "        #                         holder = self.philosophers[holder_id]\n",
    "        #                         self.log_event(\n",
    "        #                             f\"Breaking deadlock: Philosopher {holder.id} releases chopstick {needed_chopstick_id} \"\n",
    "        #                             f\"for Philosopher {longest_hungry.id}\"\n",
    "        #                         )\n",
    "        #                         self.release_chopsticks(holder)\n",
    "        #                         self.in_deadlock = False  # allow re-detection if deadlock reforms immediately\n",
    "        #                         retry_time = holder.get_retry_time()\n",
    "        #                         self.schedule_event(Event(\n",
    "        #                             self.current_time + retry_time,\n",
    "        #                             EventType.TRY_ACQUIRE_CHOPSTICKS,\n",
    "        #                             holder.id,\n",
    "        #                             holder.generation\n",
    "        #                         ))\n",
    "        #                         self.kick_front()\n",
    "        # else:\n",
    "        #     self.in_deadlock = False\n",
    "\n",
    "        is_deadlock = self.check_deadlock()\n",
    "\n",
    "        # --- A) track structural deadlock episode (independent of counting deadlock occurrences) ---\n",
    "        if is_deadlock:\n",
    "            if not self.deadlock_active:\n",
    "                self.deadlock_active = True\n",
    "                self.deadlock_start_time = self.current_time\n",
    "                self.persistent_deadlock_counted = False  # new episode, not yet counted\n",
    "        else:\n",
    "            self.deadlock_active = False\n",
    "            self.deadlock_start_time = None\n",
    "            self.persistent_deadlock_counted = False\n",
    "\n",
    "        # --- B) count \"deadlock occurrences\" ---\n",
    "        if is_deadlock:\n",
    "            if not self.in_deadlock:\n",
    "                self.in_deadlock = True\n",
    "                self.deadlock_count += 1\n",
    "                self.deadlock_times.append(self.current_time)\n",
    "                self.log_event(f\"DEADLOCK DETECTED! (occurrence #{self.deadlock_count})\")\n",
    "\n",
    "                # halt only for non-timeout\n",
    "                if self.halt_on_deadlock and self.prevention_strategy != \"timeout\":\n",
    "                    self.halted = True\n",
    "                    self.log_event(\"SIMULATION HALTED DUE TO DEADLOCK\")\n",
    "                    return\n",
    "\n",
    "                # breaker only for non-timeout\n",
    "                if self.prevention_strategy != \"timeout\":\n",
    "                    # ... dein breaker code exakt wie jetzt ...\n",
    "                    longest_hungry = None\n",
    "                    max_wait = -1.0\n",
    "                    for p in self.philosophers:\n",
    "                        if p.state == PhilosopherState.HUNGRY:\n",
    "                            wait_time = self.current_time - p.last_state_change\n",
    "                            if wait_time > max_wait or (wait_time == max_wait and (longest_hungry is None or p.id < longest_hungry.id)):\n",
    "                                max_wait = wait_time\n",
    "                                longest_hungry = p\n",
    "\n",
    "                    if longest_hungry:\n",
    "                        needed_chopstick_id = None\n",
    "                        for cid in (longest_hungry.left_chopstick_id, longest_hungry.right_chopstick_id):\n",
    "                            if cid not in longest_hungry.held_chopsticks:\n",
    "                                needed_chopstick_id = cid\n",
    "                                break\n",
    "\n",
    "                        if needed_chopstick_id is not None:\n",
    "                            holder_id = self.chopsticks[needed_chopstick_id].held_by\n",
    "                            if holder_id is not None:\n",
    "                                holder = self.philosophers[holder_id]\n",
    "                                self.log_event(\n",
    "                                    f\"Breaking deadlock: Philosopher {holder.id} releases chopstick {needed_chopstick_id} \"\n",
    "                                    f\"for Philosopher {longest_hungry.id}\"\n",
    "                                )\n",
    "                                self.release_chopsticks(holder)\n",
    "\n",
    "                                # allow re-detection\n",
    "                                self.in_deadlock = False\n",
    "\n",
    "                                retry_time = holder.get_retry_time()\n",
    "                                self.schedule_event(Event(\n",
    "                                    self.current_time + retry_time,\n",
    "                                    EventType.TRY_ACQUIRE_CHOPSTICKS,\n",
    "                                    holder.id,\n",
    "                                    holder.generation\n",
    "                                ))\n",
    "                                self.kick_front()\n",
    "        else:\n",
    "            self.in_deadlock = False\n",
    "\n",
    "        # Persistent = structural deadlock holds continuously for a time window.\n",
    "        if self.prevention_strategy == \"timeout\" and self.deadlock_active and not self.persistent_deadlock_counted:\n",
    "            if self.deadlock_start_time is not None:\n",
    "                if (self.current_time - self.deadlock_start_time) >= self.persistent_deadlock_window:\n",
    "                    self.persistent_deadlock_count += 1\n",
    "                    self.persistent_deadlock_times.append(self.deadlock_start_time)\n",
    "                    self.persistent_deadlock_counted = True\n",
    "                    self.log_event(\n",
    "                        f\"PERSISTENT DEADLOCK (structural deadlock for \"\n",
    "                        f\"{self.persistent_deadlock_window:.2f}) \"\n",
    "                        f\"(#{self.persistent_deadlock_count})\"\n",
    "                    )\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    def run(self, max_time: float = 100.0):\n",
    "        while self.event_queue and self.event_queue[0].time <= max_time:\n",
    "            if self.halted:\n",
    "                break\n",
    "            event = heapq.heappop(self.event_queue)\n",
    "            self.process_event(event)\n",
    "\n",
    "        for phil in self.philosophers:\n",
    "            phil.update_state_time(max_time if not self.halted else self.current_time)\n",
    "\n",
    "        if not self.halted:\n",
    "            self.current_time = max_time\n",
    "\n",
    "    def print_statistics(self):\n",
    "        print(f\"Simulation Statistics (Time: 0 to {self.current_time:.2f})\")\n",
    "        print(f\"Strategy: {self.prevention_strategy.upper()}\")\n",
    "\n",
    "        if self.prevention_strategy == \"timeout\":\n",
    "            print(f\"Timeout Duration: {self.timeout_duration}\")\n",
    "\n",
    "        if self.deadlock_prone:\n",
    "            print(\"Deadlock-prone timing: tighter think/eat times\")\n",
    "\n",
    "        if self.synchronized_start:\n",
    "            print(\"Synchronized start: all hungry at t=0\")\n",
    "\n",
    "        if self.halted:\n",
    "            print(\"*** SIMULATION HALTED DUE TO DEADLOCK ***\")\n",
    "\n",
    "        print()\n",
    "        print(f\"{'Philosopher':<12} {'Eat Count':<12} {'Thinking %':<15} {'Hungry %':<15} {'Eating %':<15}\")\n",
    "\n",
    "        for phil in self.philosophers:\n",
    "            think_pct = (phil.total_thinking_time / self.current_time) * 100 if self.current_time > 0 else 0\n",
    "            hungry_pct = (phil.total_hungry_time / self.current_time) * 100 if self.current_time > 0 else 0\n",
    "            eat_pct = (phil.total_eating_time / self.current_time) * 100 if self.current_time > 0 else 0\n",
    "            print(f\"{phil.id:<12} {phil.eat_count:<12} {think_pct:<15.1f} {hungry_pct:<15.1f} {eat_pct:<15.1f}\")\n",
    "\n",
    "        print()\n",
    "        total_eats = sum(p.eat_count for p in self.philosophers)\n",
    "        avg_eats = total_eats / self.num_philosophers\n",
    "        print(f\"Total Eats: {total_eats}\")\n",
    "        print(f\"Average Eats per Philosopher: {avg_eats:.2f}\")\n",
    "\n",
    "        if self.deadlock_detection:\n",
    "            print(f\"\\nDeadlocks Detected: {self.deadlock_count}\")\n",
    "            if self.deadlock_times:\n",
    "                preview = self.deadlock_times[:5]\n",
    "                suffix = \"...\" if len(self.deadlock_times) > 5 else \"\"\n",
    "                print(f\"Deadlock Times: {preview}{suffix}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Task 1: Basic Simulation\n",
    "\n",
    "Simulate 5 philosophers for 100 time units and track eating counts."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: NONE\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            2            1.5             92.2            6.3            \n",
      "1            1            3.5             88.2            8.3            \n",
      "2            0            6.1             93.9            0.0            \n",
      "3            1            12.2            87.2            0.6            \n",
      "4            0            5.5             94.5            0.0            \n",
      "\n",
      "Total Eats: 4\n",
      "Average Eats per Philosopher: 0.80\n"
     ]
    }
   ],
   "source": [
    "random.seed(100)\n",
    "np.random.seed(100)\n",
    "sim1 = DiningPhilosophersSimulation(\n",
    "    num_philosophers=5,\n",
    "    deadlock_detection=False,\n",
    "    prevention_strategy=\"none\"\n",
    ")\n",
    "sim1.run(max_time=120.0)\n",
    "sim1.print_statistics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## our own comments\n",
    "first we start our story that we did basic simulation without any deadlock detection and prevention (they are forcibly broken just to finish the simulation) just to see if the logic engine is works. \\\n",
    "in the report we will mention also MC results. \\\n",
    "add the MC run after each task and move fucntions in core engine cell. \\\n",
    "we add only MC results in the report, only in the notebokk we have solo and MC runs \\\n",
    "dont forget to comment the code for instructor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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uwr39g5lypSR9957T77//nvZtWuXpKSkSOXKlaVp06ZmtV0AAADArlwul4wZM0aioqJyvI0OTAAAAAAclbRNn7w9c+aMREREmKQtCVsAAADYXYcOHc57G03otm/fPk/aAwAAAPgkafvXX3/JwIED5ccff5TChQub0QqnTp2SFi1ayNixY6VIkSLePiQAAACQJ8aNGxfoJgAAAADn5fXwWK1bGxYWJqtWrZLVq1fLmjVr5KOPPpJjx47J8OHDvX04AAAAAAAAAMDFjLTVEbaLFi2S8uXLu7ddeumlJmF75513evtwAAAAAAAAAICLGWlbtWpV+e2337Js37NnT4ZELgAAAAAAAADATyNtlyxZ4v69SZMmMnToUNmyZYvUrl3blErYtm2bvP7669KjR48LaAIAAAAAAAAAwKuk7eTJkzNcL1q0qCxfvtxcLIUKFZL3339fHnroIU8eEgAAAAg4nS329ttvy+7du2XkyJHy1VdfmdJfDRs2DHTTAAAAkI95lLT97LPP/N8SAAAAIA/pWg29e/eWZs2ayddffy2JiYmya9cuk7x9/vnnpVWrVoFuIgAAAPIprxciU1u3bjUBbVJSUpZ97du390W7AAAAAL+aNGmSDBgwQO6++26pV6+e2TZw4EApVaqUmWlG0hYAAACOSdo+99xzMmvWLClevLhERUVl2BcSEkLSFgAAAI6gi+tef/31Wba3bNnSjLQFAAAAHJO0XbBggYwdO1Zuv/12/7QIAAAAyAPly5eXX375RSpWrJhh+xdffGH2AQAAAI5J2uqCY7Vr1/ZPawAAAIA88thjj8lTTz1lErepqamyZMkS2bt3ryxbtkwmTpwY6OYBAAAgH/M6aTto0CB55pln5JFHHpFy5cpJaGhohv26DQAAALC7m266yYyynTNnjlx++eWyatUqqVy5srz11ltSt27dQDcPAAAA+ZjXSduEhATZvHmzdO/e3dSwtbhcLnP9119/9XUbAQAAAL+oXr06o2oBAADg/KStrrLbpUsXc4mOjvZPqwAAAAA/O3TokFlgd9euXZKUlJRl/5tvvhmQdgEAAABeJ201oL377ruzLNgAAAAAOEn//v3l8OHD0qpVKwYjAAAAwNlJ2549e8qMGTPk6aeflqioKP+0CgAAAPAzLfk1f/58UyIBAAAAcHTS9ttvv5X169eb1XVLlCghYWFhGfbrAg4AAACA3eliY3/++SdJWwAAADg/aduxY0dzAQAAAJxs7Nixctddd8lnn30m5cuXz7DIrurbt2/A2gYAAID8zeukbYcOHfzTEgAAACAPvfDCC3Ls2DGzENm+ffsy7MucwAUAAADyktdJ227duuUaxLLKLgAAAJxAy3rNmTNHGjVqFOimAAAAABeXtG3cuHGG6ykpKbJnzx758ssv5cEHH/T24QAAAICAKFeunMTExAS6GQAAAMDFJ21zqu21aNEi+fjjj+W+++7z9iEBAACAPPfII4/IU089Jffee69UqFBBwsMzhsZXX311wNoGAACA/M3rpG1ONKgdNWqUV/dJTEw099Fkb3R0tPTs2dNcsivJsGbNmizbdUG0cePGyYkTJ7JMaytSpIisXr36Ap4JAAAA8oPHHnvM/Hz66aez7NNyYL/++msAWgUAAABcQNJ2//79WbadOXNGZs+ebVbd9cbEiRNl06ZN8sYbb5jHHTRokJmm1rp16wy3mzJliiQnJ7uvb9iwwQTZXbt2Ndd37NhhkrRLly513yY0NNTbpwYAAIB8ZOvWrYFuAgAAAOCbpG2LFi2yLETmcrmkbNmy8uyzz3r8OPHx8bJw4UJ59dVXpWbNmuayfft2eeutt7IkbTUha0lNTTUr/fbq1Utq165ttumKv5UrV5aSJUt6+3QAAACQj+hAAY1bNZ7NbjBCejqYAAAAAHBE0lZX2U1PA96IiAgpUaJElmTu+UY26CJm9erVc29r0KCBTJ8+XdLS0nIcKau1c7Ucwv333+/epiNtL730Um+fCgAAAPKZli1byjfffCPFixd3D0bQAQgW6zrlEQAAAOCopK23JRBycvjwYSlatKhERka6t2niV+vcHj9+XIoVK5blPhpAz5o1S7p37y4FChRwb9+5c6dJAHfq1EkOHjwoDRs2lMGDB0upUqV80lYAAAAEB50ZFhcXl+1gBAAAAMBRSdvsSiJkR2/z6aefenTgs2fPZkjYKut6UlJStvfRhcUOHDggXbp0ybBdyyNoklcTtZrY1fIJffr0MeUXwsLCxFN63/QjLRC86OfgRL/mfE74+wa74fWYFe9Xz13M+RkyZIhcd911ZqStrwYjAAAAAAFJ2vbr1y/X2rRz5syRffv2ZSh1cD5RUVFZkrPW9ejo6Gzvs3LlShNkp69xq5YtW2YSxtb9Jk+eLE2bNjULltWvX9/jNp08eTLPFjDT46SmhkpKcnKGRdacREc3O01Ksp73VDl16pQpw+Fr9Gtw9quTWecjL/++OQXv18Dg/Zoz3q+eu5jXDglxAAAABE3StkOHDtlu1yllU6ZMMYnbMWPGmPIEnipdurQcO3bMfOAMDw93l0zQxKs1ZS2zr7/+Wvr27Ztle0xMTIbrOnJCE7taKsEbelxvRuZerKRTCRIeESEREc760Gp92NF+86aOsR3o+dY+LlTon/Iavka/Bme/OpUmxwLx980peL/mPd6vOeP96v25ulBOe98AAAAg//G6pq3SUbWapP3yyy+lY8eO8sQTT2QZ/Xo+NWrUMB82169fb2rQqrVr10rt2rWzHV3y999/y549e8xiZemdPn1amjdvbpLHTZo0Mds0WasJ4SpVqngdwBPE5w/0c3CiX3M+J/x9g93wesyK96vnLvb83H777R6NZqbmLQAAAByRtNVRsbNnz5Zp06ZJpUqV5K233vKqJELm0bHt27eXkSNHmgUhDh06ZMosjBs3zj3qtlChQu6SB9u3bzclFSpUqJDhcQoWLGgSuXq/0aNHm5EpY8eOlWbNmkm1atUuqG0AAAAIXj169DBxJgAAAOD4pK0uAvbMM8+YUayPPfaYdO/e/aLrrenCYZq0veeee0zyVWvntmrVyuzTmrSaiNWRvOro0aNmumB2IysmTJgg48ePl969e5u6uC1btpRhw4ZdVNsAAAAQfDSWvOWWW0w5rUDRmFUX0dX4VW3ZskVGjBghv/32m1x22WUyatQoqVWrVsDaBwAAAIckbbX8gS72pSvsapJV69FqKYPsXH311V6NttWEq14y27ZtW4brbdu2NZfsFC5c2D1CFwAAALDrQmQaU2uJMWvNCF0bQpO47dq1M0ncd955Rx544AH55JNPJDY2NqBtBQAAgM2TtkuXLjU/9+7daxK4uY1c+PXXX33XOgAAAMCHNFmqJbcC4fjx4zJx4kSzhoNl+fLlpj0DBw40sfTQoUPlq6++khUrVrhnnAEAACD/8Shpu3XrVv+3BAAAAPCzQM7O0tllt912m1nLwbJhwwazPkP6hejq169vFuslaQsAAJB/ebUQGQAAAADvff/99/LTTz/Jhx9+aMqNWXTxXa1jm57W29VFeC+k9EOgyz/Yn3V+XOKSrGtlOAb9nAn9Gpzo1+BEvwYn+tUbnsZrJG0BAAAAP0pMTDQLjQ0fPlyio6Mz7Dt79qxERkZm2KbXdXFdb508efKiFwr2hB6jQHiauFLSRFJSxVnOfUhKTdV2O/BDZUqahKSlyZlTpyQtLc2nD02/BhD9mgP6NSf0awDRrzmgX73h6TFI2gIAAAB+NHXqVKlVq5Y0a9Ysyz6tZ5s5QavXMyd3PREXFydhYWGSJxITRcJDRcLz6Hi+8r+RLeY8/a8khaPoOQ8NlUKFCvnn8enXwKBfs0e/5o5+DQz6NXv0q1fOJbfPj6QtAAAA4EfLli2TI0eOSL169cx1K0m7cuVKufXWW82+9PR6qVKlvD6O1sO1auMie/9M2Qxx4jigf9DPGdCvwYl+DU70a3CiX73jabxG0hYAAADwo7lz50pKSor7+nPPPWd+PvHEE/Ljjz/Kq6++amqbaQCvP9etWyd9+vQJYIsBAAAQaCRtAQAAAD8qX758husFChQwPytVqmQWHfu///s/GTt2rNx5550yf/58U+e2TZs2AWotAAAA7MD/KxUAAAAAyFbBggVlxowZsnbtWunYsaNs2LBBZs6cKbGxsYFuGgAAAAKIkbYAAABAHho/fnyG63Xq1JHFixcHrD0AAACwH0baAgAAAAAAAICNkLQFAAAAAAAAABshaQsAAAAAAAAANkLSFgAAAAAAAABshKQtAAAAAAAAANgISVsAAAAAAAAAsBGStgAAAAAAAABgIyRtAQAAAAAAAMBGSNoCAAAAAAAAgI2QtAUAAAAAAAAAGyFpCwAAAAAAAAA2QtIWAAAAAAAAAGyEpC0AAAAAAAAA2AhJWwAAAAAAAACwEZK2AAAAAAAAAGAjJG0BAAAAAAAAwEZI2gIAAAAAAACAjZC0BQAAAAAAAAAbIWkLAAAAAAAAADZC0hYAAAAAAAAAbISkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMkbQEAAAAAAADARkjaAgAAAAAAAICNkLQFAAAAAAAAABsJaNI2MTFRhgwZIg0bNpSmTZvKnDlzcrztgw8+KNWqVctw+fzzz937X3/9dWnWrJnUq1fPPObZs2fz6FkAAAAAAAAAgO+ESwBNnDhRNm3aJG+88Ybs379fBg0aJOXKlZPWrVtnue3OnTtl0qRJcs0117i3FS5c2PxcuXKlTJ061ewvXry4DB482Pw+fPjwPH0+AAAAAAAAAODYkbbx8fGycOFCGTp0qNSsWVNuuukm6dWrl7z11ltZbpuUlCR79+6V2rVrS8mSJd2XyMhIs//NN9+Ue+65R5o3by516tSRUaNGyfvvv89oWwAAAAAAAACOE7Ck7datWyUlJcWUM7A0aNBANmzYIGlpaRluu2vXLgkJCZGKFStmeZzU1FT55ZdfTIkFy1VXXSXJycnmGAAAAAAAAADgJAFL2h4+fFiKFi3qHi2rSpQoYercHj9+PEvStmDBgjJw4EBT+7ZTp07y5Zdfmn0nT5409ylVqpT79uHh4VKkSBE5cOBAHj4jAAAAAAAAAHBwTVstXZA+Yaus61oOIXPSNiEhwSRse/fuLZ988olZmGzBggUm0Zv+vukfK/PjnI/L5TIXBD/6OTjRrzmfE/6+wW54PWbF+9VznB8AAAAEu4AlbaOiorIkVa3r0dHRGbY/9NBD0q1bN/fCY9WrV5fNmzfLu+++K/37989w3/SPFRMT41WbdNRuaGjeDD7W46SmhkpKcrIp5eBEWt7CaVKS9bynyqlTp7KU4fAF+jU4+9XJrPORl3/fnIL3a2Dwfs0Z71fP8doBAABAsAtY0rZ06dJy7Ngx84FTyxlYJRM0YRsXF5fhtvrBxUrYWqpUqSI7duwwZRA0AXzkyBGpWrWq2aePqSUWdLEyb+hxw8LCJK8knUqQ8IgIiYhIc+ToFu03rTXsJHq+tY8LFSrgt2PQr8HZr06lybFA/H1zCt6veY/3a854v3p/rgAAAIBgFbCkbY0aNcyHzfXr17sXEVu7dq3Url07y+iSp556ynwoHTdunHubLjJ2xRVXmNvqffS+jRs3Nvv0MfWxdUSuN/QYTvvwiwtDPwcn+jXnc8LfN9gNr8eseL96jvMDAACAYBewuXdauqB9+/YycuRI2bhxo3z66acyZ84c6d69u3vUrdaxVS1atJAPP/xQlixZIrt375apU6eaJO3dd99t9nft2lVmz55tHkMfSx+zS5cuXpdHAAAAAAAAAIB8O9JWDR482CRY77nnHilYsKD069dPWrVqZfbpomM6srZjx45m24gRI2TatGmyf/9+ufzyy2XWrFlSoUIFc9tbbrlF9u3bJ8OHDze1bPX2Tz75ZCCfGgAAAAAAAAA4L2mrI2EnTJhgLplt27Ytw/XOnTubS0569+5tLgAAAAAAAADgZCxNDAAAAAAAAAA2QtIWAAAAAAAAAGyEpC0AAAAAAAAA2AhJWwAAAAAAAACwEZK2AAAAAAAAAGAjJG0BAAAAAAAAwEZI2gIAAAAAAACAjZC0BQAAAAAAAAAbIWkLAAAAAAAAADZC0hYAAAAAAAAAbISkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMkbQEAAAAAAADARkjaAgAAAAAAAICNkLQFAAAAAAAAABshaQsAAAAAAAAANkLSFgAAAAAAAABshKQtAAAA4GcHDx6URx55RBo1aiTNmjWTcePGSWJiotm3Z88euffee+Wqq66Stm3byjfffBPo5gIAACDASNoCAAAAfuRyuUzC9uzZs/LWW2/JCy+8IJ9//rm8+OKLZt/DDz8sJUqUkPfff19uu+026du3r+zfvz/QzQYAAEAAhQfy4AAAAECw27Vrl6xfv16+/fZbk5xVmsSdMGGCXHfddWak7fz58yU2NlaqVq0q33//vUng9uvXL9BNBwAAQIAw0hYAAADwo5IlS8qsWbPcCVvL6dOnZcOGDXLllVeahK2lQYMGJskLAACA/IuRtgAAAIAfxcXFmTq2lrS0NJk3b540adJEDh8+LKVKlcpw++LFi8uBAwe8Po6WWtALcmOdH5e4JEQci37OhH4NTvRrcKJfgxP96g1P4zWStgAAAEAemjRpkmzZskXee+89ef311yUyMjLDfr2elJTk9eOePHlSQkP9P5FOj1EgPE1cKWkiKaniLOc+JKWmarsd+KEyJU1C0tLkzKlTJvnvS/RrANGvOaBfc0K/BhD9mgP61RueHoOkLQAAAJCHCds33njDLEZ2xRVXSFRUlBw/fjzDbTRhGx0dfUEjesPCwiRPJCaKhIeKhOfR8XzlfyNbzHkKceCHSj3noaFSqFAh/zw+/RoY9Gv26Nfc0a+BQb9mj371yrnk9vmRtAUAAADywOjRo+Wdd94xidubb77ZbCtdurTs2LEjw+2OHDmSpWSCJ0JCQswFOftnymaIE8cB/YN+zoB+DU70a3CiX4MT/eodT+M1FiIDAAAA/Gzq1Kkyf/58ef755+WWW25xb69bt65s3rxZEhIS3NvWrl1rtgMAACD/ImkLAAAA+NHOnTvllVdekfvvv18aNGhgFh+zLo0aNZKyZcvK4MGDZfv27TJz5kzZuHGjdOrUKdDNBgAAQABRHgEAAADwo1WrVpnaZdOmTTOX9LZt22YSukOHDpWOHTtKpUqV5OWXX5Zy5coFrL0AAAAIPJK2AAAAgB/17t3bXHKiidp58+blaZsAAABgb5RHAAAAAAAAAAAbIWkLAAAAAAAAADZC0hYAAAAAAAAAbISkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMkbQEAAAAAAADARgKatE1MTJQhQ4ZIw4YNpWnTpjJnzpwcb/vFF1/IbbfdJvXq1ZN27drJqlWrMuzXx6hWrVqGy5kzZ/LgWQAAAAAAAACA74RLAE2cOFE2bdokb7zxhuzfv18GDRok5cqVk9atW2e43datW6Vv374ycOBAuf766+Wbb76RRx99VN577z2pXr26HDx4UE6dOiWffvqpREdHu+8XGxsbgGcFAAAAAAAAAA5M2sbHx8vChQvl1VdflZo1a5rL9u3b5a233sqStF26dKk0adJEunfvbq5XqlRJPvvsM/noo49M0nbnzp1SsmRJqVixYoCeDQAAAAAAAAA4PGmro2dTUlJMuQNLgwYNZPr06ZKWliahof9UbujQoYMkJydneQwdXat27NghlStXzqOWAwAAAAAABFhMeXEcl0hYeKJIVJRIiDiPE885HCtgSdvDhw9L0aJFJTIy0r2tRIkSps7t8ePHpVixYu7tVatWzXBfHZH7/fffy5133mmu60jbs2fPSrdu3eT333+XGjVqmFq53iZyXS6XuSD40c/BiX7N+Zzw9w12w+sxK96vnuP8AADyO1dYtLhqDRMninSJuEJM/taRQsKiHZlvhvMELGmrSdb0CVtlXU9KSsrxfn///bf069dP6tevLy1btjTbdu3aJSdOnJDHH39cChYsaEou3HvvvbJs2TJz3VMnT57MMMLXn/Q4qamhkpKcnO0oYifQkdJOk5Ks5z3VjNLWEd2+Rr8GZ786mXU+8vLvm1Pwfg0M3q854/3qOV47AID8LikkVnadFklMddb/RJe4JCkhUSKjoyTEganPqLBQqVIkVqIC3RDkCwFL2kZFRWVJzlrX0y8mlt6RI0ekR48eZnTF5MmT3R9oZs+ebT5wFyhQwFx/7rnnzIJln3/+ubRr187jNsXFxUlYWJjklaRTCRIeESEREWmOHN0SHh4uISHO+iOr51v7uFChc68Vf6Bfg7NfnUqTY4H4++YUvF/zHu/XnPF+9f5cAQCQn51ITJH45FTHJW3PxidIjCvUkUnb2AhiNOSDpG3p0qXl2LFjZpSQfui0SiZowlY/rGR28OBB90Jkb775ZobyCTpCN/2oXU0IV6hQwdzHG/rB12kffnFh6OfgRL/mfE74+wa74fWYFe9Xz3F+AAAAEOwCNvdO685qsnb9+vXubWvXrpXatWtnmRIYHx8vvXr1MtvnzZtnEr7pRxvdeOONsmjRogy33717t1SpUiWPng0AAAAAAAAAOHykbUxMjLRv315Gjhwpzz77rBw6dEjmzJkj48aNc4+6LVSokBl5O2PGDPnzzz9l7ty57n1K9+ltbrjhBpkyZYqUL1/ejMB96aWXpEyZMqZEAgAAAAAAAAA4ScCStmrw4MEmaXvPPfeYBcN0gbFWrVqZfU2bNjUJ3I4dO8rKlSslISFBOnfunOH+HTp0kPHjx8uTTz5pRu0OGDBATp8+LU2aNJGZM2dSDw4AAAAAAACA4wQ0aaujbSdMmGAumW3bts39+4oVK3J9HK1h+9RTT5kLAAAAAAAAADhZwGraAgAAAAAAAACyImkLAAAAAAAAADZC0hYAAAAAAAAAbISkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMkbQEAAAAAAADARkjaAgAAAAAAAICNkLQFAAAAAAAAABshaQsAAAAAAAAANkLSFgAAAAAAAABshKQtAAAAAAAAANgISVsAAAAAAAAAsBGStgAAAAAAAABgIyRtAQAAAAAAAMBGSNoCAAAAAAAAgI2EB7oBAAAAAADAj2LKi+O4RMLCE0WiokRCxHmceM4B2ApJWwAAAAAAgpQrLFpctYaJE0W6RFwhJn/rSCFh0Y7MNwOwB5K2AAAAAAAEqaSQWNl1WiQxNU2cxCUuSUpIlMjoKAlxYOozKixUqhSJlahANwTO48RR2oyM9wuStgAAAAAABLETiSkSn5wqTkvano1PkBhXqCOTtrERYYFuAhyIkfGBE2LDkfEkbQEAAAAAAIAAY2R8YETZdGQ8SVsAAAAAAADABhgZn/dibToyPjTQDQAAAAAAAAAA/IOkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMsRAYAAAAAOCemvDiOSyQsPFEkKkocuP6NM885AMDvSNoCAAAAAMQVFi2uWsPEiSJdIq4Qk791pJCwaEfmmwEA/kPSFgAAAAAgSSGxsuu0SGJqmjiJS1ySlJAokdFREuLA1GdUWKhUKRIrUYFuCADAVkjaAgAAAACME4kpEp+cKk5L2p6NT5AYV6gjk7axEWGBbgIAwIZYiAwAAAAAAAAAbISkLQAAAAAAAADYCElbAAAAAAAAALARkrYAAAAAAAAAYCMsRAYAAADAezHlxXFcImHhiSJRUeLA9aqcec4BAMAFIWkLAAAAwCuusGhx1RomThTpEnGFmPytI4WERTsy3wwAAByUtE1MTJRRo0bJxx9/LNHR0dKzZ09zyc6WLVtkxIgR8ttvv8lll11m7lerVi33/qVLl8qLL74ohw8flqZNm8ro0aOlWLFiefhsAAAAAP/HxXaQFBIru06LJKamiZO4xCVJCYkSGR0lIQ5MfUaFhUqVIrESFeiGAACA4E7aTpw4UTZt2iRvvPGG7N+/XwYNGiTlypWT1q1bZ7hdfHy89O7dW9q1ayfjx4+Xd955Rx544AH55JNPJDY2VjZu3ChDhw41gW716tVl7NixMnjwYJkxY0bAnhsAAADg67jYTk4kpkh8cqo4LWl7Nj5BYlyhjkzaxkaEBboJAAAg2Bci00TswoULTbK1Zs2actNNN0mvXr3krbfeynLb5cuXS1RUlAwcOFCqVq1q7lOgQAFZsWKF2T9v3jxp06aNtG/f3iRtNej98ssvZc+ePQF4ZgAAAIB/4mIAAADkDwFL2m7dulVSUlKkXr167m0NGjSQDRs2SFpaxmlWuk33hYSc+zZcf9avX1/Wr1/v3t+wYUP37cuWLWtGJuh2AAAAwM68iYsBAACQPwQsaau1Z4sWLSqRkZHubSVKlDD1vI4fP57ltqVKlcqwrXjx4nLgwAHz+6FDh3LdDwAAANiVN3ExAAAA8oeA1bQ9e/ZshsBUWdeTkpI8uq11u4SEhFz3n4/LdW7tWB3hYP2eF9JSU6VobISEhThr7Vo9RzGhMVKgQKR79LNTxMVEmPOufe0v9Gtw9qtTpaamSkRERJ7/fXMK3q95j/drzni/eneuVLCcJ2/iYrvEsqmpaRKlwz8cVmLVJSESGhEq0WFOrGgr5pzr6z9F/NPP9Gtg0K/Zo19zR78GBv2aPfrVP7FswJK2WqM2cxBqXdcVcz25rXW7nPbHxMR41BZr2pku/pDXahcWEb04jp57Zy08cU6K7Nm1Tfxd7Zh+Dc5+dbJA/H1zCt6veY336/nwfvVcsJQO8CYutlssGyHOY9LhJ8WRtKd/3e//49CveYt+zRn9en70a96iX3NGv/o+lg1Y0rZ06dJy7NgxMyIgPDzcPTVMA9O4uLgstz1y5EiGbXrdKomQ0/6SJUt61BY9fu3atSU0NNRxI5YAAADyGx2VoEGuFUM6nTdxcXaIZQEAAIIvlg1YpFujRg3TOF1MzFpEbO3ate6AM726devKq6++ap6UBqL6c926ddKnTx/3fr1vx44dzfW//vrLXHS7J/R4maekAQAAAHaLi7NDLAsAABB8ArYQmZYuaN++vYwcOVI2btwon376qcyZM0e6d+/uHl2gtWpV69at5eTJkzJ27FjZsWOH+am1v9q0aWP233XXXfLBBx/IwoULzeq7AwcOlBtuuEEqVqwYqKcHAAAA+CQuBgAAQP4T4grgCg6aeNXg9OOPP5aCBQvKfffdJ/fee6/ZV61aNRk3bpx79KwGsCNGjJCdO3eafaNGjZIrr7zS/ViLFi2SyZMny4kTJ+Taa6+V0aNHm1V4AQAAALvLLS4GAABA/hPQpC0AAAAAAAAAwCblEQAAAAAAAAAAWZG0BQAAAAAAAAAbIWkLAAAAAAAAADZC0hZeSUxMlCFDhkjDhg2ladOmZmVjBI+kpCS59dZbZfXq1YFuCi7SwYMH5ZFHHpFGjRpJs2bNzMKO+v6F8+3evdssUFSvXj254YYbZNasWYFuEnyod+/e8tRTTwW6GUBQIo4NbsSxwYVYNjgRxwY/YlnfCvfx4yHITZw4UTZt2iRvvPGG7N+/XwYNGiTlypWT1q1bB7ppuEgaBA0YMEC2b98e6KbgIun6khrkxsXFyVtvvSUnTpwwH1JDQ0PNexbOlZaWZgKh2rVry+LFi03g+/jjj0vp0qWlXbt2gW4eLtKyZcvkyy+/lA4dOgS6KUBQIo4NXsSxwYVYNjgRxwY/YlnfY6QtPBYfHy8LFy6UoUOHSs2aNeWmm26SXr16mX+kcLYdO3ZIly5d5M8//wx0U+ADu3btkvXr15sRCZdffrkZUaSB79KlSwPdNFykI0eOSI0aNWTkyJFy6aWXyvXXXy/XXHONrF27NtBNw0U6fvy4SSjpBxkAvkccG7yIY4MPsWxwIo4NbsSy/kHSFh7bunWrpKSkmKkMlgYNGsiGDRvMt2ZwrjVr1kjjxo1lwYIFgW4KfKBkyZJmqlGJEiUybD99+nTA2gTfKFWqlLz44otSsGBBMwpFg9wff/zRTB2Es02YMEFuu+02ueyyywLdFCAoEccGL+LY4EMsG5yIY4Mbsax/UB4BHjt8+LAULVpUIiMj3dv0H6lOR9JvVYoVKxbQ9uHCde3aNdBNgA/pVDKt/WXRD6Pz5s2TJk2aBLRd8K0WLVqY6b3NmzeXm2++OdDNwUX4/vvv5aeffpIPP/zQjD4B4HvEscGLODb4EMsGP+LY4EIs6z+MtIXHzp49myHQVdZ1LfwPwJ4mTZokW7Zskf79+we6KfChyZMny/Tp0+XXX3810wfhTJowGjFihAwfPlyio6MD3RwgaBHHAs5FLBt8iGODB7GsfzHSFh6LiorKEtRa13lzAvYNcnXBlRdeeEGuuOKKQDcHPmTVi9JA6YknnpCBAwdmSUjA/qZOnSq1atXKMKIIgO8RxwLORCwbnIhjgwexrH+RtIXHdFXHY8eOmXpg4eHh7qlmGujqFBYA9jJ69Gh55513TLDLtKPgWcBBF+a48cYb3du0blRycrKp88b0Xmeusqv9atXZtJJIK1eulJ9//jnArQOCB3Es4DzEssGFODY4Ecv6F0lbeExXetQgV//Q6gqeSouH67dkoaFU2gDs9o3n/Pnz5fnnn5fWrVsHujnwkb1790rfvn3lyy+/NAkItWnTJhPkEug609y5c00SyfLcc8+ZnzrqBIDvEMcCzkIsG3yIY4MTsax/kbSFx2JiYqR9+/amsPSzzz4rhw4dkjlz5lCDBrCZnTt3yiuvvCK9e/c2K2PrSKL0q/HCuTS5ULNmTRkyZIgMHjxY9u3bZ0af9OnTJ9BNwwUqX758husFChQwPytVqhSgFgHBiTgWcA5i2eBEHBuciGX9i6QtvKJ/XDXYveeee6RgwYLSr18/adWqVaCbBSCdVatWSWpqqkybNs1c0tu2bVvA2oWLFxYWZj7E6HTBO+64wyQhunXrJt27dw900wDA9ohjAWcglg1OxLGA90JcLpfrAu4HAAAAAAAAAPADCjgBAAAAAAAAgI2QtAUAAAAAAAAAGyFpCwAAAAAAAAA2QtIWAAAAAAAAAGyEpC0AAAAAAAAA2AhJWwAAAAAAAACwEZK2AAAAAAAAAGAjJG0BAAAAAAAAwEZI2gKAF1q0aCHVqlVzX2rWrCmtW7eW119/3X2bbt26yZQpU3J8DL3f6tWr3Y+3aNEiCaTztfdi6fPT55n+eOnPYd26daVDhw7y3//+129tAAAAALHshSCWBRAo4QE7MgA41JAhQ6Rt27bm95SUFPnhhx9k6NChUqRIEWnfvv157//NN99I4cKFJT/r2bOnubhcLjl16pSsWrVKBg8ebM5nx44dA908AACAoEUse/GIZQHkBZK2AOClQoUKScmSJd3X9Zv1pUuXyscff+xRoJv+vvlVbGys+zyUKlVKqlatKvHx8TJp0iS55ZZbJCoqKtBNBAAACErEshePWBZAXqA8AgD4QHh4uERERLivHzx4UHr16iW1a9eWm2++Wb777rtsp5Sll5aWJrNmzZKWLVtKnTp1zNSrbdu2ufcvX77cPJY+po6O+PTTT937Dhw4II8++qg0atRIGjduLGPGjJGkpCT3lK677rpLnnvuOalXr57ccMMNsnDhwgzHzq29J0+elCeffFLq168vTZs2ldGjR0tCQoLZp89Dp4uNGDFCGjRoIDNnzrzgc3jHHXfI33//LWvXrr3gxwAAAID3iGWJZQHYD0lbALgIycnJZlTCt99+awJUy5IlS0wwumzZMqlVq5YMHDjQTJ/Kzcsvvyxz5swxU9YWL14s5cuXN8Gnfmt/9OhR8xgPPPCArFixQm6//XZ5/PHH5fjx4yagveeee+Ts2bMyd+5cefHFF+WLL76QiRMnuh/7l19+kV9//VUWLFggffv2lVGjRpmpbZ60V6fL6bSvd955R1555RXzWM8884z7vvv27TNt0ID61ltvveBzWbZsWTNqYceOHRf8GAAAAPAcsSyxLAD7ojwCAHhJv4nXb+iVfksfHR1tAs1///vf7tvoN/xWPav777/fTDnTYLVEiRLZPqYGlfPmzTPBqxUw6zFuuukms6iBjlbQoLpMmTImANYaWjrKQadeff3112Z0wbvvvuuuLzZ8+HB58MEHpX///uZ6SEiICXyLFy8uV1xxhfz444/m9jraILf2apCtoyDWrFljptJZ7dKpc1q3y6IBeaVKlS763Ooxzpw5c9GPAwAAgOwRyxLLAnAGkrYA4KVHHnlEWrVqZX7XQFPrWYWFhWW4TcWKFd2/FyxY0PxMTEzM8TE1qNSRBrr6rEWnqOlIgZ07d5rpVjoVrEePHlK5cmUTDHfu3FliYmLM/ksvvTTDghA6/UsXQvjzzz/NdQ1CNci16OPOnz//vO3Vx9apbtddd12G9uq23bt3u69XqFBBfEGDXOv4AAAA8D1iWWJZAM5A0hYAvKQB4/m+ic8c+KrcppTltFhBamqqCSp1dMGMGTNk48aNZnXaTz75RN5++21zye6+er/0P7VOWeb9oaGh522v3k5HDLz//vtZ9pcuXVo2bNiQa/u9sXfvXjl9+rRcfvnlF/1YAAAAyB6x7DnEsgDsjpq2AGADGkzqdLP169e7t+kUss2bN5vRCDpKYMKECWZqmU4T03pdWjdLp5Pp/j/++MOMbrDo42hwe8kll5jrOpIg/VStTZs2mall56OPrTXANNDW4F4vOo1Op6dZi0P4igbTOtKjYcOGPn1cAAAA+BexLLEsAN9jpC0A2MS9994rkydPllKlSpmA8tVXXzXTunRRBR0loIsnaEDcrl07s8CBLppw5ZVXyjXXXGOmhOmCCwMGDJBjx46ZWl26kEJcXJx5bK3npfXLtDaYrmirC0C88cYb521T1apVpVmzZvLEE0/IsGHDzCiGp59+2kxfsx77Qmh7Dh8+7F7RV9ujz3fs2LFZRlIAAADA/ohliWUB+BZ/TQDAJnRBBp1SpYGk/qxXr55ZQbdYsWJm/5QpU+S5556T6dOnm2ltutCDtfiCroSrwW2XLl2kQIECJhjW/RYdyaDf/Hfq1Mn8nDRpkjRo0MCjdulIhDFjxphAXINQDXw16L0YurKwXlSRIkXMNDIN8lu0aHFRjwsAAIDAIJYllgXgWyGu3ArTAAAcb9GiRTJ16lT57LPPAt0UAAAAwCvEsgDyK2raAgAAAAAAAICNkLQFAAAAAAAAABuhPAIAAAAAAAAA2AgjbQEAAAAAAADARkjaAgAAAAAAAICNkLQFAAAAAAAAABshaQsAAAAAAAAANkLSFgAAAAAAAABshKQtAAAAAAAAANgISVsAAAAAAAAAsBGStgAAAAAAAABgIyRtAQAAAAAAAEDs4/8BOVhjyDd+AHUAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1400x500 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# task 1 results\n",
    "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
    "\n",
    "# bar chart of eat counts\n",
    "eat_counts = [p.eat_count for p in sim1.philosophers]\n",
    "axes[0].bar(range(5), eat_counts, color='steelblue', alpha=0.7)\n",
    "axes[0].set_xlabel('Philosopher ID')\n",
    "axes[0].set_ylabel('Number of Times Ate')\n",
    "axes[0].set_title('Task 1: Eating Frequency per Philosopher')\n",
    "axes[0].set_xticks(range(5))\n",
    "axes[0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# bar chart of time distribution\n",
    "thinking_pct = [p.total_thinking_time / 100 * 100 for p in sim1.philosophers]\n",
    "hungry_pct = [p.total_hungry_time / 100 * 100 for p in sim1.philosophers]\n",
    "eating_pct = [p.total_eating_time / 100 * 100 for p in sim1.philosophers]\n",
    "\n",
    "x = np.arange(5)\n",
    "axes[1].bar(x, thinking_pct, label='Thinking', color='lightblue', alpha=0.8)\n",
    "axes[1].bar(x, hungry_pct, bottom=thinking_pct, label='Hungry', color='orange', alpha=0.8)\n",
    "axes[1].bar(x, eating_pct, bottom=np.array(thinking_pct) + np.array(hungry_pct), label='Eating', color='green', alpha=0.8)\n",
    "axes[1].set_xlabel('Philosopher ID')\n",
    "axes[1].set_ylabel('Time Distribution (%)')\n",
    "axes[1].set_title('Task 1: State Time Distribution')\n",
    "axes[1].set_xticks(range(5))\n",
    "axes[1].legend()\n",
    "axes[1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Task 2: Deadlock Detection\n",
    "\n",
    "Enable deadlock detection to identify when all philosophers are hungry with one chopstick each."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Simulation Statistics (Time: 0 to 19.26)\n",
      "Strategy: NONE\n",
      "*** SIMULATION HALTED DUE TO DEADLOCK ***\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            2            9.6             51.1            39.3           \n",
      "1            1            21.8            26.7            51.5           \n",
      "2            0            38.2            61.8            0.0            \n",
      "3            1            76.0            20.3            3.7            \n",
      "4            0            34.2            65.8            0.0            \n",
      "\n",
      "Total Eats: 4\n",
      "Average Eats per Philosopher: 0.80\n",
      "\n",
      "Deadlocks Detected: 1\n",
      "Deadlock Times: [19.260710064479532]\n"
     ]
    }
   ],
   "source": [
    "random.seed(100)\n",
    "np.random.seed(100)\n",
    "\n",
    "sim2 = DiningPhilosophersSimulation(\n",
    "    num_philosophers=5,\n",
    "    deadlock_detection=True,\n",
    "    prevention_strategy=\"none\",\n",
    "    halt_on_deadlock=True\n",
    ")\n",
    "\n",
    "sim2.run(max_time=120.0)\n",
    "sim2.print_statistics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Task 3: Deadlock Prevention\n",
    "\n",
    "Implement two prevention strategies:\n",
    "1. **Priority Ordering**: Always pick lower chopstick first\n",
    "2. **Timeout Strategy**: Release chopsticks after timeout and retry"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: PRIORITY\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            6            56.9            29.7            13.5           \n",
      "1            12           30.3            27.4            42.3           \n",
      "2            11           36.8            39.5            23.6           \n",
      "3            11           60.8            24.0            15.2           \n",
      "4            9            45.1            24.4            30.5           \n",
      "\n",
      "Total Eats: 49\n",
      "Average Eats per Philosopher: 9.80\n",
      "\n",
      "Deadlocks Detected: 0\n"
     ]
    }
   ],
   "source": [
    "# S1: Priority Ordering\n",
    "random.seed(100)\n",
    "np.random.seed(100)\n",
    "sim3a = DiningPhilosophersSimulation(\n",
    "    num_philosophers=5,\n",
    "    deadlock_detection=True,\n",
    "    prevention_strategy=\"priority\",\n",
    "    deadlock_prone=False,          # important for fairness\n",
    "    synchronized_start=False       # avoid forced crowding\n",
    ")\n",
    "\n",
    "sim3a.run(max_time=120.0)\n",
    "sim3a.print_statistics()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: TIMEOUT\n",
      "Timeout Duration: 2.0\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            11           52.2            22.2            25.6           \n",
      "1            11           51.5            19.7            28.8           \n",
      "2            13           49.0            37.8            13.1           \n",
      "3            12           52.0            18.6            29.4           \n",
      "4            7            49.6            29.6            20.8           \n",
      "\n",
      "Total Eats: 54\n",
      "Average Eats per Philosopher: 10.80\n",
      "\n",
      "Deadlocks Detected: 0\n"
     ]
    }
   ],
   "source": [
    "# S2: Timeout Strategy\n",
    "random.seed(200)\n",
    "np.random.seed(200)\n",
    "sim3b = DiningPhilosophersSimulation(\n",
    "    num_philosophers=5,\n",
    "    deadlock_detection=True,\n",
    "    prevention_strategy=\"timeout\",\n",
    "    timeout_duration=2.0,\n",
    "    deadlock_prone=False,          # important for fairness\n",
    "    synchronized_start=False\n",
    ")\n",
    "\n",
    "sim3b.run(max_time=120.0)\n",
    "sim3b.print_statistics()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comparison of All Strategies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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ycnJOfyaAAAAAAAAAAD4BBrjAQAAAAAAAABggyQ6AAAAAAAAAAA2SKIDAAAAAAAAAGCDJDoAAAAAAAAAADZIogMAAAAAAAAAYIMkOgAAAAAAAAAANkiiAwAAAAAAAABggyQ6AHiRli1bSpUqVRyXGjVqSJs2beT99993bNO9e3eZPHmy7XPo49auXet4vsWLF4snXW68maXvT9+n8+s578PatWtLx44d5Ysvvsi2MQAAAMD/EJu7j9gcgL8K9fQAAACuRowYIbfddpv574SEBPnll19k5MiRUqBAAenQocNlH//jjz9K/vz5JZA99NBD5pKcnCznzp2TVatWyfDhw83+7NSpk6eHBwAAAB9BbJ55xOYA/AFJdADwMnnz5pWiRYs6rmulxpIlS2TFihUZCtSdHxuocufO7dgPxYoVk4oVK8rFixdlwoQJcvvtt0tERISnhwgAAAAfQGyeecTmAPwB7VwAwAeEhoZKWFiY4/rRo0elV69eUrNmTbn11lvlf//7X5pTRp0lJSXJjBkz5Oabb5ZatWqZqZXbt2933P/VV1+Z59Ln1GqblStXOu47cuSIPPHEE3LddddJo0aN5KWXXpK4uDjHlM2uXbvKxIkTpW7dutK8eXNZtGiRy2unN97o6Gh5+umnpV69etKkSRN58cUXJSYmxtyn70Ong44ePVrq168v77777hXvw3vuuUdOnTol69evv+LnAAAAAIjNic0BBB6S6ADgxeLj402Vy08//WQCbMtnn31mgumlS5fKtddeK0OGDDHTI9Pz1ltvyaxZs8yU1E8//VRKly5tgmetAjl58qR5jr59+8qyZcvkrrvukkGDBsmZM2dMQP7AAw/IpUuXZO7cufLGG2/Id999J+PHj3c8959//il//fWXLFy4UPr16yfPP/+8mbqakfHqdFid1rlgwQJ5++23zXO98MILjscePHjQjEFPCNq1a3fF+7JkyZKmCmbnzp1X/BwAAAAIXMTmxOYAAhftXADAy2hlh1Z8KK36iIyMNIHyHXfc4dhGK0as/oG9e/c2U0o12C5SpEiaz6lB8bx580zwbQX8+hq33HKLWdRHq1/0pKBEiRImgNeehVo1o1Mrf/jhB1Ot8tFHHzn6OY4aNUoeffRRGThwoLkeFBRkAvfChQvLNddcI7/++qvZXqtX0huvniRoVc26devMVFlrXDo1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b+68SP9V3WGHVb8N1sy8ectvVbbBYRtE+o+BY+68ubV4ya+oiCOz1yUvHwi5ubx8EOflRcnN5eVrRW4+SPPyRG4+KPPyRG4+sMwd4Hl5YYroQ4cOfV1S3nt/2LCUQFbW3NwcO+20UzQ2Nub6rzYAAORDGumSEvWUhxbNuuTlidwcAICBlpcXJmsfP358vPLKK9mw/96NTpeSpkS9tbX1DX83JeivHS0DAADUNi9P5OYAAAw0hVlYdLvttsuS9JkzZ/Y9dv/99/eNYgEAAKpPXg4AQNEUJosdPnx4HHbYYXHGGWfEww8/HLfddltcfvnlcfTRR9e7awAAMGjIywEAKJqGcq2XvK/yIkYpWf/Vr34Vo0aNin/913+Nj370o/XuFgAADCrycgAAiqRQRXQAAAAAAOhPhZnOBQAAAAAA+psiOgAAAAAAVKCIDgAAAAAAFSiis86WLVsWp512Wuyxxx6x9957x+WXX17vLlEHnZ2dcdBBB8U999xT765QIy+88EKccMIJMWXKlNhnn33irLPOyl4PKL4nnngiWyRwt912i3333TcuvfTSeneJGjvmmGPiC1/4Qr27AayC3Bx5+eAjLx+85OUkcvPaaK5ROxTYOeecE4888khceeWV8eyzz8bnP//5mDBhQhxwwAH17ho1khK0k08+OWbPnl3vrlAjaU3qlKi3trbGD3/4w1i4cGH2gb2xsTF7DaC4enp6siRtp512ip/+9KdZ4n7SSSfF+PHj4+CDD65396iBm2++Oe688854//vfX++uAKsgNx/c5OWDj7x88JKXk8jNa8dIdNbJ4sWL47rrrosvfvGLscMOO8R73vOe+MQnPpG9eTM4zJkzJz74wQ/Gk08+We+uUENz586NmTNnZqNcttlmm2y0W0reb7rppnp3jSqbP39+bLfddnHGGWfE5ptvHu94xztir732ivvvv7/eXaMGFixYkBXo0oc1YOCRmw9u8vLBSV4+eMnLkZvXliI66+Rvf/tblEql7NKhXpMnT46HHnoo+6soxXfvvffGnnvuGddee229u0INjR07NrtUcKONNlrp8Y6Ojrr1idoYN25c/Od//meMGjUqG/mUkvT77rsvu3yY4jv77LPj0EMPja233rreXQFWQW4+uMnLByd5+eAlL0duXlumc2GdzJs3LzbYYIMYMmRI32PpzTtdRpj+IrbhhhvWtX9U34c//OF6d4E6SJeLpvkWe6UP5ldddVW8/e1vr2u/qK399tsvmyrgne98Z+y///717g5Vdvfdd8ef/vSnuPHGG7MRT8DAIzcf3OTlg5O8nERePvjIzWvPSHTWyZIlS1ZK0pPe+2lBG2BwOPfcc+PRRx+NE088sd5doYa+/e1vx8UXXxx//etfs0uIKa5UgPvyl78c06ZNi2HDhtW7O0AFcnNAXj44ycsHF7l5fRiJzjoZOnTo6xLy3vtOZBg8iXpavOxb3/pWbLvttvXuDjXUO/deSuJOOeWU+Pd///fXFW8ohunTp8eOO+640kg3YOCRm8PgJi8fvOTlg4vcvD4U0VknadXnV155JZt7sbm5ue8y0pSkp8vKgGI788wz4+qrr84SdpcNDp4FjNLiVe9+97v7Hktz8HV1dWVzb5oqoJhuvvnmLPa98yz3FuVuvfXWePDBB+vcO6CX3BwGL3n54CMvH7zk5vWhiM46SStBpwQ9vXCnVcCTtJhF+itoY6PZgqDof/2+5ppr4vzzz48DDjig3t2hRp5++uk47rjj4s4778yKNckjjzySJekS9eKaMWNGVpTrdd5552Vf00gnYOCQm8PgJC8fnOTlg5fcvD4U0Vknw4cPj8MOOyxbxOA//uM/4sUXX4zLL7/cHFxQcI899lhceOGFccwxx8TkyZOzUW69xo4dW9e+UV2pELPDDjvEaaedFqeeemo888wz2YinT3/60/XuGlU0ceLEle6PHDky+zpp0qQ69QhYFbk5DD7y8sFLXj54yc3rQxGddZZerFOi/i//8i8xatSoOP744+O9731vvbsFVNHtt98e3d3dcdFFF2W3Fc2aNatu/aL6mpqasg9q6ZLhI444IivYHHXUUXH00UfXu2sAyM1h0JGXD17ycqithnK5XK5xmwAAAAAAkAsmxgMAAAAAgAoU0QEAAAAAoAJFdAAAAAAAqEARHQAAAAAAKlBEBwAAAACAChTRAQAAAACgAkV0AAAAAACoQBEdAAAAAAAqUEQHGED222+/eMtb3tJ322GHHeKAAw6IK664ou9njjrqqPjOd75T8TnS791zzz19z/eTn/wk6unN+ruu0val7VyxvRX34S677BLvf//74+c//3nV+gAAQPHIzdec3BwoquZ6dwCAlZ122mlx4IEHZv8ulUrxxz/+Mb74xS/G+uuvH4cddtib/v5dd90V6623XgxmH//4x7NbuVyO9vb2uP322+PUU0/N9ufUqVPr3T0AAHJCbr7u5OZAESiiAwwwo0ePjrFjx/bdTyM1brrppvjVr361Won6ir87WI0YMaJvP4wbNy622mqrWLx4cZx77rnxvve9L4YOHVrvLgIAkANy83UnNweKwHQuADnQ3NwcLS0tffdfeOGF+MQnPhE77bRT7L///vGHP/xhlZeMrqinpycuvfTSeNe73hU777xzdmnlrFmz+r7/i1/8Inuu9JxptM1tt93W973nn38+PvvZz8aUKVNizz33jK997WvR2dnZd8nmkUceGeedd17stttuse+++8Z11123Uttv1N+2trb4v//3/8buu+8ee++9d5x55pmxdOnS7HtpO9LloF/+8pdj8uTJcckll6z1PjziiCPi5Zdfjvvvv3+tnwMAAOTmcnNg8FFEBxjAurq6slEuv//977MEu9fPfvazLJm++eabY8cdd4x///d/zy6PfCMXXHBBXH755dklqT/96U9j4sSJWfKcRoG89NJL2XN86lOfil/+8pfxz//8z3HSSSfFggULsoT8X/7lX2LJkiUxY8aM+M///M/4zW9+E+ecc07fc//5z3+Ov/71r3HttdfGcccdF1/5yleyS1dXp7/pcth0WefVV18dF154YfZcX/3qV/t+95lnnsn6kD4QHHTQQWu9LzfZZJNsFMycOXPW+jkAABi85OZyc2DwMp0LwACTRnakER9JGvUxbNiwLFE+5JBD+n4mjRjpnT/wk5/8ZHZJaUq2N9poo1U+Z0qKr7rqqiz57k34Uxvvec97skV90uiX9KFg4403zhL4NGdhGjWTLq383e9+l41W+fGPf9w3n+O0adPi2GOPjRNPPDG739DQkCXuY8aMiW233Tbuu+++7OfT6JU36m/6kJBG1dx7773ZpbK9/UqXxqZ5EnulDxSTJk1a532b2li0aNE6Pw8AAIOD3FxuDpAoogMMMCeccEK8973vzf6dEuU0f2BTU9NKP7PZZpv1/XvUqFHZ12XLllV8zpQUp5Eru+yyS99j6RLUNPLkscceyy6nTJd6fuxjH4stttgiS+Y/8IEPxPDhw7Pvb7755istiJQu70wLAT355JPZ/ZREpyS9V3rea6655k37m547Xcr6T//0Tyv1Nz32xBNP9N3fdNNNoz+kJL23fQAAeDNyc7k5QKKIDjDApIT3zUZ2vDZxT97oktFKi/V0d3dnSXEarfLd7343Hn744bj99tvj17/+dfzoRz/Kbqv63fR7K35N80K+9vuNjY1v2t/0c2kEyg033PC6748fPz4eeuihN+z/mnj66aejo6Mjttlmm3V+LgAABge5+XJyc2CwMyc6wCCQkuF0OenMmTP7HkuXiP7lL3/JRrekUSdnn312dulougw0zY+Y5ilMl4um7//973/PRsv0Ss+TkvN/+Id/yO6nkSkrXor5yCOPZJeOvpn03GnOxfRBIX04Sbd0mWy6/LR3caT+kj4MpJFDe+yxR78+LwAArAm5udwcyB8j0QEGiY9+9KPx7W9/O8aNG5clxN/73veyyzbTokJp1ElaPCgl9AcffHC2wE9aNGj77bePvfbaK7vkMy04dPLJJ8crr7ySzY2YFhJqbW3NnjvNn5jmi0xzMd5///3ZAkhXXnnlm/Zpq622in322SdOOeWUOP3007NRMV/60peyy1N7n3ttpP7Mmzcv+3dbW1vWn7S9X//61183MgcAAGpNbi43B/LFqxXAIJEWJEqXTKZEOH3dbbfdYsaMGbHhhhtm3//Od74T5513Xlx88cXZZatpoaPexYcuvPDCLDn/4Ac/GCNHjsyS+fT9XmlkTBpJcvjhh2dfzz333Jg8efJq9SuNbPna176WfZBISXRK3FPSvi4uv/zy7Jasv/762WWi6UPKfvvtt07PCwAA/UFuLjcH8qWh/EYTdQHAm/jJT34S06dPjzvuuKPeXQEAgEFNbg5QHeZEBwAAAACAChTRAQAAAACgAtO5AAAAAABABUaiAwAAAABABYroAAAAAABQgSI6AAAAAABUoIgOAAAAAAAVKKIDAAAAAEAFiugAAAAAAFCBIjoAAAAAAFSgiA4AAAAAALFq/z+qa1aFSmkKTAAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 1500x1000 with 4 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "strategies = {\n",
    "    'Basic (No Prevention)': sim1,\n",
    "    'With Detection': sim2,\n",
    "    'Priority Ordering': sim3a,\n",
    "    'Timeout': sim3b\n",
    "}\n",
    "\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for idx, (name, sim) in enumerate(strategies.items()):\n",
    "    eat_counts = [p.eat_count for p in sim.philosophers]\n",
    "    axes[idx].bar(range(5), eat_counts, color=['steelblue', 'darkorange', 'green', 'red', 'purple'], alpha=0.7)\n",
    "    axes[idx].set_xlabel('Philosopher ID')\n",
    "    axes[idx].set_ylabel('Eat Count')\n",
    "    axes[idx].set_title(f'{name}\\nTotal: {sum(eat_counts)}, Avg: {sum(eat_counts)/5:.1f}')\n",
    "    axes[idx].set_xticks(range(5))\n",
    "    axes[idx].grid(axis='y', alpha=0.3)\n",
    "    \n",
    "    # deadlock count\n",
    "    if hasattr(sim, 'deadlock_count') and sim.deadlock_detection:\n",
    "        axes[idx].text(0.5, 0.95, f'Deadlocks: {sim.deadlock_count}', \n",
    "                      transform=axes[idx].transAxes, ha='center', va='top',\n",
    "                      bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "STRATEGY COMPARISON SUMMARY\n",
      "             Strategy  Total Eats Avg Eats Std Dev  Deadlocks\n",
      "Basic (No Prevention)           4     0.80    0.75          0\n",
      "       With Detection           4     0.80    0.75          1\n",
      "    Priority Ordering          49     9.80    2.14          0\n",
      "              Timeout          54    10.80    2.04          0\n"
     ]
    }
   ],
   "source": [
    "summary_data = []\n",
    "for name, sim in strategies.items():\n",
    "    total_eats = sum(p.eat_count for p in sim.philosophers)\n",
    "    avg_eats = total_eats / 5\n",
    "    std_eats = np.std([p.eat_count for p in sim.philosophers])\n",
    "    deadlocks = sim.deadlock_count if hasattr(sim, 'deadlock_count') else 'N/A'\n",
    "    \n",
    "    summary_data.append({\n",
    "        'Strategy': name,\n",
    "        'Total Eats': total_eats,\n",
    "        'Avg Eats': f\"{avg_eats:.2f}\",\n",
    "        'Std Dev': f\"{std_eats:.2f}\",\n",
    "        'Deadlocks': deadlocks\n",
    "    })\n",
    "\n",
    "df_summary = pd.DataFrame(summary_data)\n",
    "print(\"STRATEGY COMPARISON SUMMARY\")\n",
    "print(df_summary.to_string(index=False))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Leftâ€‘First vs Priority (Randomized vs Synchronized)\n",
    "\n",
    "Compare leftâ€‘first (default) against lowestâ€‘ID priority under both randomized and synchronized starts.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- Leftâ€‘First / Randomized Start ---\n",
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: NONE\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            13           25.7            45.9            28.4           \n",
      "1            10           30.1            33.6            36.4           \n",
      "2            8            44.2            37.5            18.3           \n",
      "3            14           41.3            39.5            19.2           \n",
      "4            10           31.3            44.9            23.8           \n",
      "\n",
      "Total Eats: 55\n",
      "Average Eats per Philosopher: 11.00\n",
      "\n",
      "Deadlocks Detected: 0\n",
      "--- Leftâ€‘First / Synchronized Start ---\n",
      "Simulation Statistics (Time: 0 to 0.00)\n",
      "Strategy: NONE\n",
      "Deadlock-prone timing: tighter think/eat times\n",
      "Synchronized start: all hungry at t=0\n",
      "*** SIMULATION HALTED DUE TO DEADLOCK ***\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            0            0.0             0.0             0.0            \n",
      "1            0            0.0             0.0             0.0            \n",
      "2            0            0.0             0.0             0.0            \n",
      "3            0            0.0             0.0             0.0            \n",
      "4            0            0.0             0.0             0.0            \n",
      "\n",
      "Total Eats: 0\n",
      "Average Eats per Philosopher: 0.00\n",
      "\n",
      "Deadlocks Detected: 1\n",
      "Deadlock Times: [0.0]\n",
      "--- Priority / Randomized Start ---\n",
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: PRIORITY\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            5            41.1            38.0            20.9           \n",
      "1            7            33.2            42.1            24.8           \n",
      "2            10           40.2            33.3            26.5           \n",
      "3            16           39.5            21.1            39.4           \n",
      "4            8            31.6            39.4            29.0           \n",
      "\n",
      "Total Eats: 46\n",
      "Average Eats per Philosopher: 9.20\n",
      "\n",
      "Deadlocks Detected: 0\n",
      "--- Priority / Synchronized Start ---\n",
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: PRIORITY\n",
      "Deadlock-prone timing: tighter think/eat times\n",
      "Synchronized start: all hungry at t=0\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            0            0.0             100.0           0.0            \n",
      "1            0            0.0             100.0           0.0            \n",
      "2            0            0.0             100.0           0.0            \n",
      "3            163          0.0             27.2            72.8           \n",
      "4            0            0.0             100.0           0.0            \n",
      "\n",
      "Total Eats: 163\n",
      "Average Eats per Philosopher: 32.60\n",
      "\n",
      "Deadlocks Detected: 0\n"
     ]
    }
   ],
   "source": [
    "def run_compare(name, sim_kwargs, max_time=120.0, seed=123):\n",
    "    random.seed(seed)\n",
    "    np.random.seed(seed)\n",
    "    sim = DiningPhilosophersSimulation(**sim_kwargs)\n",
    "    sim.run(max_time=max_time)\n",
    "    print(f'--- {name} ---')\n",
    "    sim.print_statistics()\n",
    "    return sim\n",
    "\n",
    "# Leftâ€‘first (default: prevention_strategy='none')\n",
    "lf_random = run_compare(\n",
    "    'Leftâ€‘First / Randomized Start',\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='none', synchronized_start=False),\n",
    "    max_time=120.0, seed=101\n",
    ")\n",
    "\n",
    "lf_sync = run_compare(\n",
    "    'Leftâ€‘First / Synchronized Start',\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='none', synchronized_start=True, deadlock_prone=True, halt_on_deadlock=True),\n",
    "    max_time=120.0, seed=102\n",
    ")\n",
    "\n",
    "# Priority (lowestâ€‘ID first)\n",
    "pr_random = run_compare(\n",
    "    'Priority / Randomized Start',\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='priority', synchronized_start=False),\n",
    "    max_time=120.0, seed=103\n",
    ")\n",
    "\n",
    "pr_sync = run_compare(\n",
    "    'Priority / Synchronized Start',\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='priority', synchronized_start=True, deadlock_prone=True),\n",
    "    max_time=120.0, seed=104\n",
    ")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Task 4: Starvation Avoidance\n",
    "\n",
    "Implementing a fairness mechanism so that all philosophers have a chance to eat.\n",
    "\n",
    "Global Waiter: When a philosopher becomes hungry, put they are put in a queue. Only the philosopher at the front is allowed to try to acquire chopsticks. When they start eating, remove them from the queue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Simulation Statistics (Time: 0 to 120.00)\n",
      "Strategy: PRIORITY\n",
      "\n",
      "Philosopher  Eat Count    Thinking %      Hungry %        Eating %       \n",
      "0            7            40.6            43.3            16.1           \n",
      "1            10           36.2            40.1            23.7           \n",
      "2            9            33.9            45.3            20.7           \n",
      "3            11           37.0            29.4            33.6           \n",
      "4            7            41.4            49.0            9.7            \n",
      "\n",
      "Total Eats: 44\n",
      "Average Eats per Philosopher: 8.80\n",
      "\n",
      "Deadlocks Detected: 0\n"
     ]
    }
   ],
   "source": [
    "# S4: Starvation Avoidance\n",
    "random.seed(100)\n",
    "np.random.seed(100)\n",
    "sim4 = DiningPhilosophersSimulation(\n",
    "    num_philosophers=5,\n",
    "    deadlock_detection=True,\n",
    "    prevention_strategy=\"priority\",\n",
    "    starvation_prevention=True,\n",
    "    deadlock_prone=False,          # important for fairness\n",
    "    synchronized_start=False,      # avoid forced crowding\n",
    ")\n",
    "\n",
    "sim4.run(max_time=120.0)\n",
    "sim4.print_statistics()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 156,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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d94xNWS//vprKVeunMycOZNasAAAAAicpO2rr75qppf169dPRo0aJU2bNpXbbrvNrLwLAAAAWFHp0qVN/AoAAADYTXBenqRTxnTRhpUrV0r37t3l77//Nj910YbU1FRZs2aNJCcn+761AAAAQB517NhRfv755zw//8cff5QOHTr4tE0AAACA1xci04UUHnnkEXM7ePCgLFmyRJYtWybDhw+X8ePHS8uWLRnNAAAAAEsYNGiQDBs2TI4dO2Zmif3rX/8yi5JpXVsdeHDixAnZvn27rFu3zsS0WvNWFwkDAAAAbJW0TevSSy+Vzp07m9tff/3lTuCStLWv8PBwfzcBAICAx9/bgqOL5c6aNcuMtp0zZ44899xzcvr06XTPKV68uNx8880ycuRIqVevnt/aCgAAAHglaZtWpUqVTLkEvRVm5xKS5XxSitiRU0QuKRMnx88liV2X54gKD5UikWH+bgYAoADY9W8uf2/948YbbzQ3tW/fPjl+/LhZkExr3uoCZQAAAEBAJm1xgV48fv7LHjkVnyR243Q65ezZs1K0aFFbrqp8SXS43Fe3ou0uIgEAhetvLn9v/a9ChQrmBgAAAFgZSVsv04vHE2cTxW70IvL06fOSLGG2vIgEABQ+dvyby99bAAAAAHkRLPmkizeow4cPy5dffim7d+/O764AAAAAAAAAAPlN2urquo0aNZK1a9eahG2bNm1k8ODBct9995nkLQAAAAAAAACgAJO2o0aNkhYtWkjNmjXl008/lYiICPnhhx9k+PDh8s4771xEUwAAAAAAAAAAHte0/eOPP0xyNioqSr777ju54447JDw8XOrVqydDhw71TSsBAACAi7BlyxYZMWKE/P7775KSkpLp8a1bt/qlXQAAAIBXkralS5eWnTt3Snx8vAl+X375ZbP9xx9/lHLlynm6OwAAAMDn+vfvL8WKFZO3335bihYt6u/mAAAAAN5N2j7++OPy7LPPSnBwsNSoUcOMsJ08ebJMmDDBlE4AAAAArEYXzf3iiy+kYsWK/m4KAAAA4P2kbceOHaVu3bpy4MABadiwodnWoEEDadq0qVx77bWe7g4AAADwuapVq8quXbtI2gIAACAwk7aqWrVqEhYWJitXrpSbb75ZSpUqJRUqVPB+6wAAAAAvaNmypQwcOFDatGljErcay6bVqlUrv7UNAAAAuOik7alTp+S5556TtWvXitPplK+//lpGjhwpe/fulalTp0pcXJynuwQAAAB8atq0aRIZGSnLli3L9FhQUBBJWwAAANg7aaur7kZFRclPP/0kTZo0MdteffVVeemll8xjkyZN8kU7AQAAgHz77rvv/N0EAAAAwHdJWy2JMGvWLImJiXFvK1mypPTr10/at2/v6e4AAACAAnH48GH56KOPTG1bh8MhV1xxhbRr104qVark76YBAAAA6QRLPiQmJmbadvz4cQkNzVeJXAAAAMCnfvnlF7nzzjtlzZo1Zi0Gvf3888+m1u26dev83TwAAAAgHY+zrPfcc4+pYTts2DBT/ys+Pt6UShgyZIi0aNHC090BAAAAPvfaa6/Jo48+Ki+88EK67ePGjZOxY8fKnDlz/NY2AAAA4KJH2vbp00dq1qxpVt7VhK2OTnjyySflpptuMo8BAAAAVrNjxw65//77M21v27atbN261S9tAgAAALw20jY8PFxefvllef7552Xv3r2mHthll10mRYoU8XRXAAAAQIGIi4uTjRs3Zqpfu2HDBildurTf2gUAAABkJV9FaLdt2ya7d++WpKQk932XVq1a5WeXAAAAgM907tzZlPPSGPb66693J2x1gd3evXv7u3kAAADAxSVtte7XtGnTpFSpUhIREZHuMa1xS9IWAAAAVqOlvdTs2bPlgw8+MHFs5cqVzVoNd911l7+bBwAAAFxc0nbu3LkmuM2qJhgAAABg5cStK3kLAAAABFTStlixYlKjRg3ftAYAAADwkgkTJpgFc6OioszvOenevXuBtQsAAADwetK2b9++MmzYMOnZs6eUL19egoOD0z2u2wAAAAB/W7NmjXTs2NEkbfX37GiJLwAAAMDWSduEhATZvHmzCYDTBrhOp9Pc37p1q7fbCAAAAHhMFxlzGT16tFx66aWZBhw4HI50i+oCAAAAtkzajh07Vh544AFzi4yM9E2rAAAAAC+69dZb5YcffpCSJUum275v3z55+OGHZcOGDX5rGwAAAHDRSdukpCR59NFH5bLLLvP0pQAAAECBmTdvnkyePNk9K0wX0s040vb06dNSpUoVP7UQAAAA8FLStlOnTjJlyhQZNGiQREREePpyAAAAoEC0atVKwsLCJDU1Vfr37y9PPPGEWVTXRUt7ab3bBg0a+LWdAAAAwEUnbXVa2fr162Xx4sVSunRp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jh07PDqGvhe9ITeuc+QUp1xIlNsSfZ0F+jawBUD/0rfZoG8DF33ribzGcR4nbe+++24ZOHCgKZNQo0YNs01HDQwbNkxatGjh6e4AAAAAn7j99ttl37595ve1a9fKDTfcIEWKFEn3HK0lq8/zlvj4eLPew5w5c8zoWk3UDh48WKKiouT8+fMSHh6e7vl6Xxcu84QOltD6vAVBj1MkNFWcKakiKQ6xlwsXRLoGh9jxAjIlVYJSU+XcmTNm8Wdvo2/9iL4N3P6lb3NB32aHvg3cvs1KXo/jcdL2ueeek2PHjsmTTz7pzgyHhIRIu3btTH0uAAAAwAo0Qdu9e3fzu45+1cEHGZOm3qZ1a8+ePSuvv/66OaY6cOCAWXSsYsWKmRK0ej8yMtKjY8TExJj4u8AkJoqEBouEFuAxvSHNtYr8f0kKW9FzHhwsxYoV890x6Fv/oG8Dt3/p25zRtzmjbwO3bzO4kNz2QdJWA11d7bZ///7y119/mfuXX345K94CAADAsu69916ZN2+eNGnSRMqXLy9vv/22fP3111KtWjWzIFjx4sW9chwttaCLjbkStqpy5cryzz//mDq3R48eTfd8vR8bG+vRMbQWrqsuLrL3v+mZQXYb85MefZ0JfRvYAqJ/6dss0beBi771TF7juHzPq9Jv+HVF3GuvvZaELQAAACxNBx28++67prTAt99+K++99560bNnSJFOHDx/utePUrFlTEhMT5c8//3Rv2717t0ni6mO//fabe7aa/vz111/NdgAAACCtgimGBQAAAPjRsmXLZPz48WbAwZdffikNGzaULl26yJAhQ+S///2v145zxRVXSNOmTaVfv36ybds2WblypUydOlUeeughad68uUkajxw5Unbu3Gl+ap3bu+66y2vHBwAAQGAgaQsAAICAp8nRUqVKSUpKinz//fdyyy23uBeC0Dq03jRu3DhTPkwTtX379pVHHnlEOnToIEWLFpUpU6bIunXrpE2bNmYxX03oMmsNAAAAGXkcoS5ZssSMTPBW3S8AAADA12rXri1jx441iVNN4N52221mJKyWRmjQoIFXj6ULWYwZMybLx7S82KJFi7x6PAAAAAQej0favvLKK3L8+HHftAYAAADwgREjRkhycrJs3rxZRo0aZUbdapkE/aklEgAAAABbj7StX7++GW379NNPS3h4uG9aBQAAAHhRuXLlZNKkSem29erVy2/tAQAAALyatD127JhZeXfy5MlSsmRJiYiISPf48uXLPd0lAAAA4HUTJkyQJ598UqKioszvOenevXuBtQsAAADwetL2gQceMDcAAADAytasWSMdO3Y0SVv9PTtBQUEF2i4AAADA60nb1q1bu38/deqUWWhBA12CXQAAAFjJrFmzsvwdAAAACLikrdPpNKURZsyYIWfOnJGvvvpK3n77bYmOjpaBAwdS5xYAAACWcuTIEVmxYoXs2rVLzp07J0WKFJFrrrlGmjZtKsWLF/d38wAAAIBMgsVDEydOlM8//1xee+01d4JWR9/+8MMPMmbMGE93BwAAAPiM1rJt1qyZjBw5UlatWiU7d+40cevgwYNN0nbq1Kn+biIAAABw8SNtFy1aZBK2N954o7skws033yyjR4+W5557zoy2BQAAAPztww8/lOnTp8uQIUPkvvvuSzcjLCkpyQxEGDVqlMTGxkqrVq382lYAAADgopK2x44dM4FtRjExMRIfH+/p7gAAAACfmDt3rvTr10/atm2b6TFN4Or2hIQE+fjjj0naAgAAwN7lERo0aCDvv/9+um1nz56VN954Q+rXr+/NtgEAAAD5tnfvXhO75qRx48by559/FlibAAAAAJ8kbYcOHSpbtmwxJRESExPlmWeekSZNmsj+/fspjQAAAADL0BIIulhuTvRxHYAAAAAA2Lo8wqWXXirz58+X1atXy+7duyUlJUUqV64sDRs2lOBgj3PAAAAAgE/o+guuNRgAAACAgE7apk3enjt3TsLCwkzSloQtAAAArMTpdMqIESMkIiIi2+fozDEAAADA9knbf/75R/r06SM///yzXHLJJSYYPnPmjDRr1kxGjhwpxYsX901LAQAAAA+0bt061+doQpdFyAAAAGD7pK3WrQ0JCZHly5dLXFyc2fbXX39J//79ZfDgwfLOO+/4op0AAACAR0aNGuXvJgAAAAAFk7TVEbYLFy50J2xVpUqVTMK2ffv2+WsFAAAAAAAAAMDwuBBtlSpV5I8//si0fe/evekSuQAAAAAAAAAAH420Xbx4sfv3Bg0ayIABA2TLli1So0YNUyph+/btMmPGDHniiSfy0QQAAAAAAAAAgEdJ24x1akuUKCHLli0zN5dixYrJggUL5JlnnsnLLgEAAAAAAAAA+U3afvfdd3l5GgAAAGBZWs7r448/lj179sjQoUPl+++/N2sz1K1b199NAwAAAC5uITK1bds22b17tyQlJWV6rFWrVvnZJQAAAOAzuphuly5dpFGjRrJy5UpJTEw08awmb9944w254447/N1EAAAAIP9J23Hjxsm0adOkVKlSEhERke6xoKAgkrYAAACwnLFjx8oLL7wgjz76qNSqVcts69Onj8TGxppSYCRtAQAAYOuk7dy5c2XkyJFy//33+6ZFAAAAgJf98ccf0qRJk0zbb731VjPSFgAAALCSYE9foAuO1ahRwzetAQAAAHwgLi5Ofv/990zb//vf/5rHAAAAAFuPtO3bt68MGzZMevbsKeXLl5fg4PR5X90GAAAAWMnzzz8vL7/8skncOhwOWbx4sezbt0+WLl0qY8aM8XfzAAAAgItL2iYkJMjmzZulY8eOpoati9PpNPe3bt3q6S4BAAAAn7r99tvlsssuk+nTp8tVV10ly5cvl8qVK8tHH30kNWvW9HfzAAAAgItL2uoiDg888IC5RUZGevpyAAAAwC+uvfZaRtUCAADrirJpySanSEhookhEhMj/xnfaQ1Rc4CRtk5KSzKq7OlIBAAAAsIPDhw/LtGnTZPfu3SaezejDDz/0S7sAAACUMyRSnNUHil2FO0WcQSZ/aztBIZGWzDV7nLTt1KmTTJkyRQYNGiQRmkEHAAAALK5Xr15y5MgRueOOO5gtFmCjUAJy1I9dzzkAIN+SgqJl91mRREeq2I1TnJKUkCjhkRESZLM/uhEhwXJF8WiJCISk7Q8//CDr1683izeULl1aQkJC0j2u9cEAAAAAK9E1GebMmWNKJKDwjPyx86gfK4/8AQD4xqnEFIlPdogdk7bn4xMkyhlsu6RtdFj6vKatk7Zt2rQxNwAAAMAudLGxv//+m6RtIRr5Y+dRP1Yf+QMAACyYtG3durVvWgIAAAD4yMiRI+Whhx6S7777TuLi4iQoKH0Sr3v37n5rmx3YceSPnUf9WH3kDwAAsGDStkOHDpmC3LRYxAEAAABW8+abb8qJEyfMQmT79+9P91hOsS0AAADgDx4nbevXr5/ufkpKiuzdu1dWrFgh3bp182bbAAAAAK/QdRemT58u9erV83dTAAAAAO8nbbObOrZw4UL5+uuv5cknn/R0lwAAAIBPlS9fXqKiovzdDAAAAMA3Sdvs3HjjjfLKK694a3cAAACA1/Ts2VNefvllefzxx6VChQoSGhqaKZYFAAAAbJu0PXDgQKZt586dk/fff98s6gAAAABYzfPPP29+Dho0KNNjWtN269atfmgVAAAA4KWkbbNmzTIt1uB0OqVcuXLy6quvero7AAAAwOe2bdvm7yYAAAAAvkva6iIOaWkCNywsTEqXLs3KuwAAALAMnSGmAws0Rs1qtljGmrcAAACAbZO2lEAAAACAHdx6662yatUqKVWqlHu2mM4Qc3HdpzwCAAAAbJm0zaokQlb0Od9++634QpcuXaRkyZLy2muv+WT/AAAACCxauismJibL2WIAAACA7ZO2PXr0yPax+Ph4mT59uuzfv19q1aolvrB06VJZsWKFtG7d2if7BwAAQODp37+/NG7c2Iy0ZbYYAAAAAi5pm12yVEcsjB8/3iRuR4wYIW3btvV2++TkyZMyZswYqVGjhtf3DQAAgMCVthQCAAABI8qmX0Q6RUJCE0UiIkTstiSSXc85CldNW6WjajVJq6Nf27RpIy+++KIUL17c+60TkdGjR0vLli3l8OHDPtk/AAAAAhcL5QIAAokzJFKc1QeKXYU7RZxBJn9rO0EhkbbLNaMQJW1TUlLk/fffl0mTJknFihXlo48+8llJBLV69Wr55Zdf5IsvvpChQ4f67DgAAAAITPfff78EBwfn+jxq3gIA7CApKFp2nxVJdKSK3TjFKUkJiRIeGSFBNkt/RoQEyxXFoyXC3w1BoZLnpO2aNWtk2LBhcujQIXn++eelY8eOeQqA8ysxMVGGDBkigwcPlsjIyIuaFsfUuMKDvg5c9G3gom8DF30buAqyby/2WE888YQUK1bMa+0BAMDfTiWmSHyyQ+yYtD0fnyBRzmDbJW2jw0L83QQUQnlK2mr5A10MTBdw0BGvZcuWlXXr1mX53BtvvNErDZswYYJUr15dGjVqdFH7OX36tE+Tyy56DIcjWFKSkyU5OVnsSkdT21FKsp5/h5w5c0ZSU737jSN9G7h9Gyj9S99mjb71H/o2d/Rt3l3McbQ0wt13320WIgMQQHUa7VwX067nHABgzaTtkiVLzM99+/aZBG5OgfHWrVu90jBNEh89etRdfiEpKcn8/Oqrr+S3337L835iYmIkJKRgvhFJOpMgoWFhEhZmw2kK/z+KJTQ01Ja13/S8az8XK1bEJ/unbwO3b+3cv/Rt7uhb/6Bvs0ffek6TxPnFaG8gcGtj2rkupqI2JgDAK0nbbdu2SUGbNWtWulEo48aNMz9zShpnRS+I7HhRhPyhrwMXfRu46NvARd8GroLs24s5VuvWrSVCR+IBCKjamHaui6mojQkA8PpCZAVJSzGkVaTIhREdugAaAAAAkJtRo0b5uwmA5dmxNqad62IqamMCAPLC98VeAQAAAAAAAAD2H2mb0WuvvebvJgAAAAAAAACAzzHSFgAAAPCBLl26yMsvv+y+v2XLFmnXrp3UrFlT7r//ftm0aZNf2wcAAADrImkLAAAAeNnSpUtlxYoV7vvx8fEmiVu3bl1ZuHCh1KpVS7p27Wq2AwAAALYtjwAAAADYwcmTJ2XMmDFSo0YN97Zly5ZJRESE9OnTR4KCgmTAgAHy/fffy7///W9p06aNX9sLIEBFpV/c2zacIiGhiSIREWK7debses4BWBJJWwAAAMCLRo8eLS1btpTDhw+7t23YsEHq1KljErZKf9auXVvWr19P0haA1zlDIsVZfaDYVbhTxBlk8re2ExQSabtcMwBrImkLAAAAeMnq1avll19+kS+++EKGDh3q3n7kyBG58sor0z23VKlSsmPHDj+0EkCgSwqKlt1nRRIdqWI3TnFKUkKihEdGSJDN0p8RIcFyRfFoifB3QwAEBJK2AAAAgBckJibKkCFDZPDgwRIZGZnusfPnz0t4eHi6bXo/KSnJ4+M4nU5zK1h6PDuOeXNx2rbNvu9r+jZQ+/ZUYrLEJzvEbvSsnI9PkChnsM1StiLRYSHmJ/9u88Ju7ee/yXlnt/Y7L/xvAcZWeT0WSVsAAADACyZMmCDVq1eXRo0aZXpM69lmTNDq/YzJ3bw4ffq0BAcXzHrCepywyChxOBzmZieuyyFtt90SP8oRLJKamipn4s+Zn95G3/oPfRu4/Uvf5oy+zR59G7h9m5W8HoekLQAAAOAFS5culaNHj0qtWrXMfVeS9quvvpJ77rnHPJaW3o+NjfX4ODExMRIScmE0V0FIcqSa44Wk2vMCUttutwtIV7v1Ir5YsWI+OwZ96x/0beD2L32bM/o2Z/Rt4PZtRnlNzJO0BQAAALxg1qxZkpKS4r4/btw48/PFF1+Un3/+Wd577z0zHU4XIdOfv/76qzz99NMeH0df71rQrODo8ex2GZZ26qHd2q7+t2id749jt/ND3+b9OHY8P3buX/o2Z/Rt3o5jt3Oj6FtP5PVYJG0BAAAAL4iLi0t3v0iRIuZnxYoVzaJjr7/+uowcOVLat28vc+bMMXVu77rrLj+1FgAAAFZWMMWwAAAAgEKsaNGiMmXKFFm3bp20adNGNmzYIFOnTpXo6Gh/Nw0AAAAWxEhbAAAAwAdee+21dPevv/56WbRokd/aAwAAAPtgpC0AAAAAAAAAWAhJWwAAAAAAAACwEJK2AAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAAALIWkLAAAAAAAAABZC0hYAAAAAAAAALISkLQAAAAAAAABYCElbAAAAAAAAALAQkrYAAAAAAAAAYCEkbQEAAAAAAADAQkjaAgAAAAAAAICFkLQFAAAAAAAAAAshaQsAAAAAAAAAFkLSFgAAAAAAAAAshKQtAAAAAAAAAFgISVsAAAAAAAAAsBCStgAAAAAAAABgISRtAQAAAAAAAMBCSNoCAAAAAAAAgIWQtAUAAAAAAAAACyFpCwAAAAAAAAAWQtIWAAAAAAAAACyEpC0AAAAAAAAAWAhJWwAAAAAAAACwEJK2AAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAAALIWkLAAAAAAAAABZC0hYAAAAAAAAALISkLQAAAAAAAABYCElbAAAAAAAAALAQkrYAAAAAAAAAYCEkbQEAAAAAAADAQkjaAgAAAAAAAICFkLQFAAAAAAAAAAshaQsAAAAAAAAAFkLSFgAAAAAAAAAshKQtAAAAAAAAAFgISVsAAAAAAAAAsBCStgAAAAAAAABgISRtAQAAAAAAAMBCSNoCAAAAAAAAgIWQtAUAAAAAAAAACyFpCwAAAAAAAAAWYumk7aFDh6Rnz55Sr149adSokYwaNUoSExP93SwAAAAAAAAA8JlQsSin02kStjExMfLRRx/JqVOnpH///hIcHCx9+/b1d/MAAAAAAAAAoHCNtN29e7esX7/ejK696qqrpG7duiaJu2TJEn83DQAAAAAAAAAKX9K2TJkyMm3aNCldunS67WfPnvVbmwAAAAAAAACg0JZH0LIIWsfWJTU1VWbPni0NGjTwuMyC3lA40NeBi74NXPRt4KJvA1dB9i2fIwAAABRGlk3aZjR27FjZsmWLzJ8/36PXnT592tTB9TU9hsMRLCnJyZKcnCx2lZKSInaUkqzn3yFnzpwxCX5vom8Dt28DpX/p26zRt/5D3+aOvs27gjoOAAAAYCWhdknYzpw5U9588025+uqrPR6xGxISIgUh6UyChIaFSViY/S4uXKNYQkNDJSgoSOxGz7v2c7FiRXyyf/o2cPvWzv1L3+aOvvUP+jZ79K3nNElsJ4cOHZKRI0fKTz/9JBEREdKiRQvp3bu3+X3v3r0yaNAgs25D+fLlzSK7DRs29HeTAQAAYEGWT9oOHz5cPvnkE5O4vfPOOz1+vV4Q2fGiCPlDXwcu+jZw0beBi74NXAXZt3b6HGlSXhfO1UEDH330kZw6dcokZnV0eJ8+feTZZ581AxAWLFgg3377rXTv3l2WLVtmErgAAACAbZK2EyZMkDlz5sgbb7whzZs393dzAAAAgGzt3r3bjKL94Ycf3IvpahJ39OjR0rhxYzPSVmPb6OhoqVKliqxevdokcHv06OHvpgMAAMBiLJu03bVrl7z77rvSpUsXqVOnjhw5csT9WJkyZfzaNgAAACAjjVGnTZvmTti6nD17VjZs2CDVqlUzCVsXjXE1yQsAAADYJmm7fPlyU8Ns0qRJ5pbW9u3b/dYuAAAAICtaFqFRo0bpFlGbPXu2NGjQwAxAiI2NTff8UqVKycGDB/NVhsFVH7ng6PEK+pje5LRtm33f1/RtwaNv885u7adv885u7adv885u7Xde+N8CjK3yeizLJm11hK3eAAAAADvSNRm2bNki8+fPlxkzZkh4eHi6x/V+UlKSx/s9ffq0qZNbEPQ4YZFRZjCF3RaFc10OabvtUxn5fxzBFxL/Z+LPmZ/eRt/6D30buP1L3+aMvs0efRu4fZuVvB7HsklbAAAAwM4J25kzZ8qbb75pFh+LiIiQkydPpnuOJmwjIyPzNaI3JCRECkqSI9UcL6RgrmO8fgGpbbfbBaSr3XoRX6xYMZ8dg771D/o2cPuXvs0ZfZsz+jZw+zajvCbmSdoCAAAAXjR8+HD55JNPTOL2zjvvNNvKli0rO3fuTPe8o0ePZiqZkBdBQUHmVrD0eHa7DEs79dBubf9fm33f1/RtwaNvA7d/6duc0bd5O47dzo2ibz2R12MVzLwqAAAAoBCYMGGCzJkzR9544w25++673dtr1qwpmzdvloSEBPe2devWme0AAABARiRtAQAAAC/YtWuXvPvuu/LUU09JnTp1zOJjrlu9evWkXLly0q9fP9mxY4dMnTpVNm7cKG3btvV3swEAAGBBlEcAAAAAvGD58uWmRtmkSZPMLa3t27ebhO6AAQOkTZs2UrFiRZk4caKUL1/eb+0FAACAdZG0BQAAALygS5cu5pYdTdTOnj27QNsEAAAAe6I8AgAAAAAAAABYCElbAAAAAAAAALAQkrYAAAAAAAAAYCEkbQEAAAAAAADAQkjaAgAAAAAAAICFkLQFAAAAAAAAAAshaQsAAAAAAAAAFkLSFgAAAAAAAAAshKQtAAAAAAAAAFgISVsAAAAAAAAAsBCStgAAAAAAAABgISRtAQAAAAAAAMBCSNoCAAAAAAAAgIWQtAUAAAAAAAAACyFpCwAAAAAAAAAWQtIWAAAAAAAAACyEpC0AAAAAAAAAWAhJWwAAAAAAAACwEJK2AAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAAALIWkLAAAAAAAAABZC0hYAAAAAAAAALISkLQAAAAAAAABYCElbAAAAAAAAALAQkrYAAAAAAAAAYCEkbQEAAAAAAADAQkjaAgAAAAAAAICFkLQFAAAAAAAAAAshaQsAAAAAAAAAFkLSFgAAAAAAAAAshKQtAAAAAAAAAFgISVsAAAAAAAAAsBCStgAAAAAAAABgISRtAQAAAAAAAMBCSNoCAAAAAAAAgIWQtAUAAAAAAAAACyFpCwAAAAAAAAAWQtIWAAAAAAAAACyEpC0AAAAAAAAAWAhJWwAAAAAAAACwEJK2AAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAAALIWkLAAAAAAAAABZC0hYAAAAAAAAALISkLQAAAAAAAABYCElbAAAAAAAAALAQkrYAAAAAAAAAYCEkbQEAAAAAAADAQiydtE1MTJT+/ftL3bp1pWHDhjJ9+nR/NwkAAADIN+JbAAAA5EWoWNiYMWNk06ZNMnPmTDlw4ID07dtXypcvL82bN/d30wAAAACPEd8CAADA1knb+Ph4mTdvnrz33nty3XXXmduOHTvko48+IqgFAACA7RDfAgAAwPblEbZt2yYpKSlSq1Yt97Y6derIhg0bJDU11a9tAwAAADxFfAsAAADbJ22PHDkiJUqUkPDwcPe20qVLmzpgJ0+e9GvbAAAAAE8R3wIAAMD25RHOnz+fLqBVrvtJSUm5vt7pdJqfOprB9buvpTocUiI6TEKCCuZ43qTnKCo4SooUCZegoCCxm5ioMHP+tb99gb4N3L61c//St7mjb/2Dvs0efes5h8NhfhZUPOdLdoxvlcORKhE61CNEbMUpQRIcFiyRIUFiv39tYs65fv5TxHd9Td/6B30buP1L3+aMvs0ZfRu4fZvf+NaySduIiIhMwavrfmRkZK6vd00x04UeClKNS0REb7ak5/XCB8d+UmTv7u2y14dHoG8Dt2/t3b/0bW7oW3+gb3NG3+ZHIJQPsGt86xIm9mNS4qfFlrS3tx4omGPRtwWLvg3c/qVvc0ff5o6+Ddy+9TS+tWzStmzZsnLixAkzkiA0NNQ9pUwD2piYmFxfr6+pUaOGBAcH23IkCwAAAC6MQNCA1hUP2hnxLQAAAJx5jG8tG/1WrVrVNH79+vVSt25ds23dunXuQDU3+pyM088AAAAAfyG+BQAAgO0XIouKipJWrVrJ0KFDZePGjfLtt9/K9OnTpWPHjv5uGgAAAOAx4lsAAADkVZDTwqs66GINGtR+/fXXUrRoUXnyySfl8ccf93ezAAAAgHwhvgUAAIDtk7YAAAAAAAAAUNhYtjwCAAAAAAAAABRGJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0hSQmJkr//v2lbt260rBhQ7OKMQJLUlKS3HPPPbJmzRp/NwVecujQIenZs6fUq1dPGjVqJKNGjTL/lmF/e/bsMQsT1apVS5o2bSrTpk3zd5PgA126dJGXX37Z380AAhbxbeAjvg08xLeBi/i2cCC+9b5QH+wTNjNmzBjZtGmTzJw5Uw4cOCB9+/aV8uXLS/Pmzf3dNHiBBjovvPCC7Nixw99NgZfo+pEa0MbExMhHH30kp06dMhemwcHB5t8v7Cs1NdUEOzVq1JBFixaZALd3795StmxZuffee/3dPHjJ0qVLZcWKFdK6dWt/NwUIWMS3gY34NvAQ3wYu4tvCgfjWNxhpW8jFx8fLvHnzZMCAAXLdddfJ7bffLp07dzZ/KGF/O3fulAceeED+/vtvfzcFXrR7925Zv369GX1w1VVXmVFEGuQuWbLE303DRTp69KhUrVpVhg4dKpUqVZImTZrITTfdJOvWrfN30+AlJ0+eNMkkvXAB4BvEt4GN+DYwEd8GLuLbwEd86zskbQu5bdu2SUpKipmm4FKnTh3ZsGGD+UYM9rZ27VqpX7++zJ07199NgReVKVPGTCkqXbp0uu1nz571W5vgHbGxsfLWW29J0aJFzYgTDWZ//vlnM00QgWH06NHSsmVLufLKK/3dFCBgEd8GNuLbwER8G7iIbwMf8a3vUB6hkDty5IiUKFFCwsPD3dv0D6VOOdJvS0qWLOnX9uHiPPzww/5uAnxAp41pnS8XvQCdPXu2NGjQwK/tgnc1a9bMTOm95ZZb5M477/R3c+AFq1evll9++UW++OILM9oEgG8Q3wY24tvARHxbOBDfBh7iW99ipG0hd/78+XQBrXLd1+L+AKxv7NixsmXLFunVq5e/mwIveuedd2Ty5MmydetWM1UQ9qbJoiFDhsjgwYMlMjLS380BAhrxLWB/xLeBifg2sBDf+h4jbQu5iIiITMGr6z7/6AB7BLS6yMqbb74pV199tb+bAy9y1YTSYOjFF1+UPn36ZEpCwD4mTJgg1atXTzeKCIBvEN8C9kZ8G7iIbwML8a3vkbQt5HTFxhMnTpi6X6Ghoe4pZRrQ6hQVANY1fPhw+eSTT0xgy/SiwFmoQRfhuO2229zbtDZUcnKyqenGlF57r6ir/euqselKIH311Vfy22+/+bl1QGAhvgXsi/g28BDfBi7iW98jaVvI6SqOGszqf0R1hU6lhcH1G7DgYKpnAFb+VnPOnDnyxhtvSPPmzf3dHHjJvn37pHv37rJixQqTdFCbNm0ywSwBrb3NmjXLJJBcxo0bZ37qKBMA3kV8C9gT8W1gIr4NXMS3vkfStpCLioqSVq1amYLRr776qhw+fFimT59OfRnAwnbt2iXvvvuudOnSxayGraOH0q68C/vShMJ1110n/fv3l379+sn+/fvNSJOnn37a303DRYqLi0t3v0iRIuZnxYoV/dQiIHAR3wL2Q3wbuIhvAxfxre+RtIX5D6cGtY899pgULVpUevToIXfccYe/mwUgG8uXLxeHwyGTJk0yt7S2b9/ut3bh4oWEhJgLFp0a+OCDD5rEQ4cOHaRjx47+bhoA2ArxLWAvxLeBi/gWyL8gp9PpvIjXAwAAAAAAAAC8iKJOAAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAAALIWkLAAAAAAAAABZC0hYAAAAAAAAALISkLQAAAAAAAABYCElbAAAAAAAAALAQkrYAkEazZs3kmmuucd+uu+46ad68ucyYMcP9nA4dOsj48eOz3Ye+bs2aNe79LVy4UPwpt/ZeLH1/+j7THi/tOaxZs6a0bt1aPv/8c5+1AQAAAFkjvvUc8S0AKwj1dwMAwGr69+8vLVq0ML+npKTITz/9JAMGDJDixYtLq1atcn39qlWr5JJLLpHCrFOnTubmdDrlzJkzsnz5cunXr585n23atPF38wAAAAoV4tuLR3wLoKCRtAWADIoVKyZlypRx39dv0ZcsWSJff/11noLatK8trKKjo93nITY2VqpUqSLx8fEyduxYufvuuyUiIsLfTQQAACg0iG8vHvEtgIJGeQQAyIPQ0FAJCwtz3z906JB07txZatSoIXfeeaf8+OOPWU4fSys1NVWmTZsmt956q1x//fVmmtX27dvdjy9btszsS/epIyG+/fZb92MHDx6U5557TurVqyf169eXESNGSFJSknv61kMPPSTjxo2TWrVqSdOmTWXevHnpjp1Te0+fPi0vvfSS1K5dWxo2bCjDhw+XhIQE85i+D50aNmTIEKlTp45MnTo13+fwwQcflOPHj8u6devyvQ8AAAB4B/Et8S0AayNpCwA5SE5ONiMQfvjhBxOMuixevNgEnkuXLpXq1atLnz59zFSpnEycOFGmT59upqctWrRI4uLiTKCp39AfO3bM7KNr167y73//W+6//37p3bu3nDx50gSvjz32mJw/f15mzZolb731lvz3v/+VMWPGuPf9+++/y9atW2Xu3LnSvXt3eeWVV8w0try0V6fG6RSvTz75RN59912zr2HDhrlfu3//ftMGDZ7vueeefJ/LcuXKmREKO3fuzPc+AAAAcHGIb4lvAdgD5REAIAP91l2/jVf6jXxkZKQJKu+77z73c/TbfFftqqeeespML9PAtHTp0lnuUwPI2bNnm0DVFRzrMW6//XazgIGOTNAA+tJLLzXBrtbL0hENOs1q5cqVZiTBp59+6q4lNnjwYOnWrZv06tXL3A8KCjJBbqlSpeTqq6+Wn3/+2TxfRxbk1F4NqHXEw9q1a820OVe7dJqc1uhy0eC7YsWKF31u9Rjnzp276P0AAAAg74hviW8B2A9JWwDIoGfPnnLHHXeY3zWo1NpVISEh6Z5z2WWXuX8vWrSo+ZmYmJjtPjWA1FEFutKsi05H01EBu3btMlOrdNrXE088IZUrVzaBb7t27SQqKso8XqlSpXSLP+hUL1304O+//zb3NeDUgNZF9ztnzpxc26v71mltjRs3Ttde3bZnzx73/QoVKog3aEDrOj4AAAAKBvEt8S0A+yFpCwAZaHCY27fuGYNcldP0sewWJnA4HCaA1JEEU6ZMkY0bN5qVaL/55hv5+OOPzS2r1+rr0v7UmmQZHw8ODs61vfo8HR2wYMGCTI+XLVtWNmzYkGP7PbFv3z45e/asXHXVVRe9LwAAAOQd8e0FxLcA7ISatgBQADRw1Kll69evd2/T6WKbN282Iw90RMDo0aPNNDKdEqa1ubRGlk4d08f/+usvM5LBRfejgezll19u7uuogbTTsjZt2mSmkeVG9631vjSo1kBebzplTqeiuRaC8BYNnHVUR926db26XwAAABQ84lviWwC+xUhbACggjz/+uLzzzjsSGxtrgsf33nvPTOHSBRR0RIAulKDB77333msWM9AFEqpVqyY33XSTmf6liyu88MILcuLECVOXSxdNiImJMfvW2l1aq0zrgOnqtbrYw8yZM3NtU5UqVaRRo0by4osvysCBA82IhUGDBpmpaq5954e258iRI+7Ve7U9+n5HjhyZadQEAAAA7In4lvgWgO/wXxYAKCC6+IJOn9KgUX/WqlXLrJZbsmRJ8/j48eNl3LhxMnnyZDOFTRd1cC20oKveaiD7wAMPSJEiRUzgq4+76KgF/Za/bdu25ufYsWOlTp06eWqXjjoYMWKECbo14NQgVwPci6GrCOtNFS9e3EwZ04C+WbNmF7VfAAAAWAfxLfEtAN8JcuZUpAYAYHkLFy6UCRMmyHfffefvpgAAAAAXjfgWAKhpCwAAAAAAAACWQtIWAAAAAAAAACyE8ggAAAAAAAAAYCGMtAUAAAAAAAAACyFpCwAAAAAAAAAWQtIWAAAAAAAAACyEpC0AAAAAAAAAWAhJWwAAAAAAAACwEJK2AAAAAAAAAGAhJG0BAAAAAAAAwEJI2gIAAAAAAACAhZC0BQAAAAAAAACxjv8DOV3oQv6rQjgAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1400x500 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# task 4 results\n",
    "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
    "\n",
    "# bar chart of eat counts\n",
    "eat_counts = [p.eat_count for p in sim4.philosophers]\n",
    "axes[0].bar(range(5), eat_counts, color='steelblue', alpha=0.7)\n",
    "axes[0].set_xlabel('Philosopher ID')\n",
    "axes[0].set_ylabel('Number of Times Ate')\n",
    "axes[0].set_title('Task 4: Starvation Prevention')\n",
    "axes[0].set_xticks(range(5))\n",
    "axes[0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# bar chart of time distribution\n",
    "thinking_pct = [p.total_thinking_time / 100 * 100 for p in sim4.philosophers]\n",
    "hungry_pct = [p.total_hungry_time / 100 * 100 for p in sim4.philosophers]\n",
    "eating_pct = [p.total_eating_time / 100 * 100 for p in sim4.philosophers]\n",
    "\n",
    "x = np.arange(5)\n",
    "axes[1].bar(x, thinking_pct, label='Thinking', color='lightblue', alpha=0.8)\n",
    "axes[1].bar(x, hungry_pct, bottom=thinking_pct, label='Hungry', color='orange', alpha=0.8)\n",
    "axes[1].bar(x, eating_pct, bottom=np.array(thinking_pct) + np.array(hungry_pct), label='Eating', color='green', alpha=0.8)\n",
    "axes[1].set_xlabel('Philosopher ID')\n",
    "axes[1].set_ylabel('Time Distribution (%)')\n",
    "axes[1].set_title('Task 4: State Time Distribution')\n",
    "axes[1].set_xticks(range(5))\n",
    "axes[1].legend()\n",
    "axes[1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 157,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Without Starvation Prevention\n",
      "-----------------------------\n",
      "Total simulation time      : 120.00\n",
      "Total eats                 : 49\n",
      "Average eats               : 9.80\n",
      "Eat count std deviation    : 2.14\n",
      "Min / Max eats             : 6 / 12\n",
      "\n",
      "Average hungry time        : 34.79\n",
      "Maximum hungry time        : 47.43\n",
      "Average eating time        : 30.03\n",
      "\n",
      "Throughput (eats / time)   : 0.408\n",
      "\n",
      "With Starvation Prevention\n",
      "--------------------------\n",
      "Total simulation time      : 120.00\n",
      "Total eats                 : 44\n",
      "Average eats               : 8.80\n",
      "Eat count std deviation    : 1.60\n",
      "Min / Max eats             : 7 / 11\n",
      "\n",
      "Average hungry time        : 49.68\n",
      "Maximum hungry time        : 58.76\n",
      "Average eating time        : 24.92\n",
      "\n",
      "Throughput (eats / time)   : 0.367\n"
     ]
    }
   ],
   "source": [
    "def compute_statistics(sim):\n",
    "    eat_counts = np.array([p.eat_count for p in sim.philosophers])\n",
    "    hungry_times = np.array([p.total_hungry_time for p in sim.philosophers])\n",
    "    eating_times = np.array([p.total_eating_time for p in sim.philosophers])\n",
    "\n",
    "    stats = {\n",
    "        \"total_time\": sim.current_time,\n",
    "        \"total_eats\": eat_counts.sum(),\n",
    "        \"avg_eats\": eat_counts.mean(),\n",
    "        \"eat_std\": eat_counts.std(),\n",
    "        \"min_eats\": eat_counts.min(),\n",
    "        \"max_eats\": eat_counts.max(),\n",
    "\n",
    "        \"avg_hungry_time\": hungry_times.mean(),\n",
    "        \"max_hungry_time\": hungry_times.max(),\n",
    "\n",
    "        \"avg_eating_time\": eating_times.mean(),\n",
    "\n",
    "        \"throughput\": eat_counts.sum() / sim.current_time if sim.current_time > 0 else 0\n",
    "    }\n",
    "\n",
    "    return stats\n",
    "\n",
    "\n",
    "def print_statistics(stats, title=\"Simulation Statistics\"):\n",
    "    print(f\"\\n{title}\")\n",
    "    print(\"-\" * len(title))\n",
    "\n",
    "    print(f\"Total simulation time      : {stats['total_time']:.2f}\")\n",
    "    print(f\"Total eats                 : {stats['total_eats']}\")\n",
    "    print(f\"Average eats               : {stats['avg_eats']:.2f}\")\n",
    "    print(f\"Eat count std deviation    : {stats['eat_std']:.2f}\")\n",
    "    print(f\"Min / Max eats             : {stats['min_eats']} / {stats['max_eats']}\")\n",
    "    print()\n",
    "    print(f\"Average hungry time        : {stats['avg_hungry_time']:.2f}\")\n",
    "    print(f\"Maximum hungry time        : {stats['max_hungry_time']:.2f}\")\n",
    "    print(f\"Average eating time        : {stats['avg_eating_time']:.2f}\")\n",
    "    print()\n",
    "    print(f\"Throughput (eats / time)   : {stats['throughput']:.3f}\")\n",
    "\n",
    "stats_no_prevention = compute_statistics(sim3a)\n",
    "stats_with_prevention = compute_statistics(sim4)\n",
    "\n",
    "print_statistics(stats_no_prevention, \"Without Starvation Prevention\")\n",
    "print_statistics(stats_with_prevention, \"With Starvation Prevention\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Monte Carlo Check (Tasks 1â€“4)\n",
    "\n",
    "Run multiple simulations with different seeds to estimate averages, deadlock probability, and fairness.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 235,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Basic (No Prevention) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.78 Â± 8.33\n",
      "Avg eats/philosopher: 9.16 Â± 1.67\n",
      "Avg std (fairness): 1.54\n",
      "Deadlock runs: 0/50\n",
      "\n",
      "=== Basic + FIFO Starvation Prevention ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.58 Â± 5.82\n",
      "Avg eats/philosopher: 9.12 Â± 1.16\n",
      "Avg std (fairness): 1.36\n",
      "Deadlock runs: 0/50\n",
      "\n",
      "=== Detection (Synchronized) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.78 Â± 8.33\n",
      "Avg eats/philosopher: 9.16 Â± 1.67\n",
      "Avg std (fairness): 1.54\n",
      "Deadlock runs: 6/50\n",
      "\n",
      "=== Priority Ordering ===\n",
      "Runs: 50\n",
      "Avg total eats: 52.52 Â± 6.21\n",
      "Avg eats/philosopher: 10.50 Â± 1.24\n",
      "Avg std (fairness): 1.85\n",
      "Deadlock runs: 0/50\n",
      "\n",
      "=== Priority + FIFO Starvation Prevention ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.76 Â± 6.40\n",
      "Avg eats/philosopher: 9.15 Â± 1.28\n",
      "Avg std (fairness): 1.38\n",
      "Deadlock runs: 0/50\n",
      "\n",
      "=== Timeout ===\n",
      "Runs: 50\n",
      "Avg total eats: 52.80 Â± 4.47\n",
      "Avg eats/philosopher: 10.56 Â± 0.89\n",
      "Avg std (fairness): 1.76\n",
      "Deadlock runs: 2/50\n",
      "\n",
      "=== Timeout + FIFO Starvation Prevention ===\n",
      "Runs: 50\n",
      "Avg total eats: 44.88 Â± 6.24\n",
      "Avg eats/philosopher: 8.98 Â± 1.25\n",
      "Avg std (fairness): 1.29\n",
      "Deadlock runs: 0/50\n",
      "\n"
     ]
    }
   ],
   "source": [
    "def run_monte_carlo(sim_kwargs, runs=50, max_time=100.0, base_seed=1000):\n",
    "    results = []\n",
    "    for i in range(runs):\n",
    "        seed = base_seed + i\n",
    "        random.seed(seed)\n",
    "        np.random.seed(seed)\n",
    "        sim = DiningPhilosophersSimulation(**sim_kwargs)\n",
    "        sim.run(max_time=max_time)\n",
    "        eat_counts = [p.eat_count for p in sim.philosophers]\n",
    "        results.append({\n",
    "            'seed': seed,\n",
    "            'total_eats': sum(eat_counts),\n",
    "            'avg_eats': np.mean(eat_counts),\n",
    "            'std_eats': float(np.std(eat_counts)),\n",
    "            'min_eats': min(eat_counts),\n",
    "            'max_eats': max(eat_counts),\n",
    "            'deadlocks': sim.deadlock_count,\n",
    "            'halted': sim.halted,\n",
    "            'eat_counts': eat_counts,\n",
    "        })\n",
    "    return pd.DataFrame(results)\n",
    "\n",
    "mc_basic = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=False, prevention_strategy='none'),\n",
    "    runs=50, max_time=120.0, base_seed=1000\n",
    ")\n",
    "\n",
    "mc_detect = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='none', halt_on_deadlock=True),\n",
    "    runs=50, max_time=120.0, base_seed=1000\n",
    ")\n",
    "\n",
    "mc_priority = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='priority'),\n",
    "    runs=50, max_time=120.0, base_seed=3000\n",
    ")\n",
    "\n",
    "mc_timeout = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='timeout', timeout_duration=2.0),\n",
    "    runs=50, max_time=120.0, base_seed=4000\n",
    ")\n",
    "\n",
    "mc_basic_fifo = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=False, prevention_strategy=\"none\", starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=5000\n",
    ")\n",
    "\n",
    "mc_priority_fifo = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"priority\", starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=6000\n",
    ")\n",
    "\n",
    "mc_timeout_fifo = run_monte_carlo(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"timeout\",\n",
    "         timeout_duration=2.0, starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=7000\n",
    ")\n",
    "\n",
    "\n",
    "def summarize_mc(df, name):\n",
    "    print(f'=== {name} ===')\n",
    "    print(f'Runs: {len(df)}')\n",
    "    print(f'Avg total eats: {df.total_eats.mean():.2f} Â± {df.total_eats.std():.2f}')\n",
    "    print(f'Avg eats/philosopher: {df.avg_eats.mean():.2f} Â± {df.avg_eats.std():.2f}')\n",
    "    print(f'Avg std (fairness): {df.std_eats.mean():.2f}')\n",
    "    deadlock_runs = (df.deadlocks > 0).sum()\n",
    "    print(f'Deadlock runs: {deadlock_runs}/{len(df)}')\n",
    "    print()\n",
    "\n",
    "summarize_mc(mc_basic, \"Basic (No Prevention)\")\n",
    "summarize_mc(mc_basic_fifo, \"Basic + FIFO Starvation Prevention\")\n",
    "summarize_mc(mc_detect, \"Detection (Synchronized)\")\n",
    "summarize_mc(mc_priority, \"Priority Ordering\")\n",
    "summarize_mc(mc_priority_fifo, \"Priority + FIFO Starvation Prevention\")\n",
    "summarize_mc(mc_timeout, \"Timeout\")\n",
    "summarize_mc(mc_timeout_fifo, \"Timeout + FIFO Starvation Prevention\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "remove this part: === Basic + FIFO Starvation Prevention === \\\n",
    "use only randomized stats"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "do the bar plots with mean and std"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 236,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Basic (No Prevention) (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.86 Â± 9.92\n",
      "Avg eats/philosopher: 9.17 Â± 1.98\n",
      "Avg min/max eats: 7.14 / 11.20\n",
      "Avg Gini (fairness): 0.090\n",
      "Deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [9.32, 9.08, 9.3, 9.28, 8.88]\n",
      "Per-philosopher std eats: [2.8, 2.59, 2.59, 2.31, 2.31]\n",
      "Zero-eat rate by philosopher: [0.02, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Basic + FIFO Starvation Prevention (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 43.90 Â± 5.73\n",
      "Avg eats/philosopher: 8.78 Â± 1.15\n",
      "Avg min/max eats: 6.94 / 10.42\n",
      "Avg Gini (fairness): 0.075\n",
      "Deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [8.84, 8.78, 8.88, 8.96, 8.44]\n",
      "Per-philosopher std eats: [1.65, 1.87, 1.58, 1.77, 1.82]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Detection (Synchronized) (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.86 Â± 9.92\n",
      "Avg eats/philosopher: 9.17 Â± 1.98\n",
      "Avg min/max eats: 7.14 / 11.20\n",
      "Avg Gini (fairness): 0.090\n",
      "Deadlock runs: 4/50\n",
      "Avg first deadlock time: 53.30\n",
      "Per-philosopher avg eats: [9.32, 9.08, 9.3, 9.28, 8.88]\n",
      "Per-philosopher std eats: [2.8, 2.59, 2.59, 2.31, 2.31]\n",
      "Zero-eat rate by philosopher: [0.02, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Priority Ordering (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 51.64 Â± 6.66\n",
      "Avg eats/philosopher: 10.33 Â± 1.33\n",
      "Avg min/max eats: 7.66 / 13.04\n",
      "Avg Gini (fairness): 0.101\n",
      "Deadlock runs: 0/50\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [8.84, 10.26, 10.76, 12.06, 9.72]\n",
      "Per-philosopher std eats: [2.15, 2.1, 2.21, 2.19, 2.29]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Priority + FIFO Starvation Prevention (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.36 Â± 5.90\n",
      "Avg eats/philosopher: 9.07 Â± 1.18\n",
      "Avg min/max eats: 7.46 / 10.86\n",
      "Avg Gini (fairness): 0.072\n",
      "Deadlock runs: 0/50\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [8.78, 9.06, 9.02, 9.14, 9.36]\n",
      "Per-philosopher std eats: [1.66, 1.78, 1.89, 1.64, 1.97]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Timeout (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 54.46 Â± 5.03\n",
      "Avg eats/philosopher: 10.89 Â± 1.01\n",
      "Avg min/max eats: 8.40 / 13.34\n",
      "Avg Gini (fairness): 0.087\n",
      "Deadlock runs: 1/50\n",
      "Avg first deadlock time: 4.59\n",
      "Avg timeout releases/run: 22.46 Â± 5.55\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [11.28, 10.76, 10.98, 10.6, 10.84]\n",
      "Per-philosopher std eats: [2.06, 2.07, 2.45, 1.84, 2.07]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Timeout + FIFO Starvation Prevention (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 45.10 Â± 6.55\n",
      "Avg eats/philosopher: 9.02 Â± 1.31\n",
      "Avg min/max eats: 7.12 / 11.00\n",
      "Avg Gini (fairness): 0.084\n",
      "Deadlock runs: 0/50\n",
      "Avg timeout releases/run: 8.66 Â± 4.97\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [8.74, 8.76, 9.18, 9.04, 9.38]\n",
      "Per-philosopher std eats: [2.12, 2.05, 1.68, 1.9, 2.17]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "    \n",
    "def gini_coefficient(x):\n",
    "    x = np.array(x, dtype=float)\n",
    "    if np.allclose(x, 0):\n",
    "        return 0.0\n",
    "    x = np.sort(x)\n",
    "    n = len(x)\n",
    "    cumx = np.cumsum(x)\n",
    "    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n\n",
    "\n",
    "def run_monte_carlo_detailed(sim_kwargs, runs=50, max_time=100.0, base_seed=5000):\n",
    "    results = []\n",
    "    for i in range(runs):\n",
    "        seed = base_seed + i\n",
    "        random.seed(seed)\n",
    "        np.random.seed(seed)\n",
    "\n",
    "        sim = DiningPhilosophersSimulation(**sim_kwargs)\n",
    "        sim.run(max_time=max_time)\n",
    "\n",
    "        eat_counts = [p.eat_count for p in sim.philosophers]\n",
    "        hungry_times = [p.total_hungry_time for p in sim.philosophers]\n",
    "        eating_times = [p.total_eating_time for p in sim.philosophers]\n",
    "        thinking_times = [p.total_thinking_time for p in sim.philosophers]\n",
    "\n",
    "        # results.append({\n",
    "        #     \"seed\": seed,\n",
    "        #     \"total_eats\": int(sum(eat_counts)),\n",
    "        #     \"avg_eats\": float(np.mean(eat_counts)),\n",
    "        #     \"std_eats\": float(np.std(eat_counts)),\n",
    "        #     \"min_eats\": int(min(eat_counts)),\n",
    "        #     \"max_eats\": int(max(eat_counts)),\n",
    "        #     \"gini_eats\": float(gini_coefficient(eat_counts)),\n",
    "        #     \"deadlocks\": int(sim.deadlock_count),\n",
    "        #     \"first_deadlock_time\": (min(sim.deadlock_times) if sim.deadlock_times else None),\n",
    "        #     \"eat_counts\": eat_counts,\n",
    "        #     \"hungry_times\": hungry_times,\n",
    "        #     \"eating_times\": eating_times,\n",
    "        #     \"thinking_times\": thinking_times,\n",
    "        #     \"timeout_releases\": int(sim.timeout_release_count),\n",
    "        # })\n",
    "\n",
    "        row = {\n",
    "            \"seed\": seed,\n",
    "            \"total_eats\": int(sum(eat_counts)),\n",
    "            \"avg_eats\": float(np.mean(eat_counts)),\n",
    "            \"std_eats\": float(np.std(eat_counts)),\n",
    "            \"min_eats\": int(min(eat_counts)),\n",
    "            \"max_eats\": int(max(eat_counts)),\n",
    "            \"gini_eats\": float(gini_coefficient(eat_counts)),\n",
    "            \"deadlocks\": int(sim.deadlock_count),\n",
    "            \"first_deadlock_time\": (min(sim.deadlock_times) if sim.deadlock_times else None),\n",
    "            \"eat_counts\": eat_counts,\n",
    "            \"hungry_times\": hungry_times,\n",
    "            \"eating_times\": eating_times,\n",
    "            \"thinking_times\": thinking_times,\n",
    "            # \"timeout_releases\": int(sim.timeout_release_count),\n",
    "        }\n",
    "\n",
    "        strategy = sim_kwargs.get(\"prevention_strategy\")\n",
    "\n",
    "        if strategy == \"timeout\":\n",
    "            row[\"timeout_releases\"] = int(sim.timeout_release_count)\n",
    "\n",
    "        if strategy in {\"timeout\", \"priority\"}:\n",
    "            row[\"persistent_deadlocks\"] = int(getattr(sim, \"persistent_deadlock_count\", 0))\n",
    "            row[\"first_persistent_deadlock_time\"] = (\n",
    "                min(getattr(sim, \"persistent_deadlock_times\", []))\n",
    "                if getattr(sim, \"persistent_deadlock_times\", [])\n",
    "                else None\n",
    "            )\n",
    "\n",
    "\n",
    "        results.append(row)\n",
    "\n",
    "    return pd.DataFrame(results)\n",
    "\n",
    "def summarize_detailed(df, name):\n",
    "    print(f\"=== {name} (Detailed) ===\")\n",
    "    print(f\"Runs: {len(df)}\")\n",
    "    print(f\"Avg total eats: {df.total_eats.mean():.2f} Â± {df.total_eats.std():.2f}\")\n",
    "    print(f\"Avg eats/philosopher: {df.avg_eats.mean():.2f} Â± {df.avg_eats.std():.2f}\")\n",
    "    print(f\"Avg min/max eats: {df.min_eats.mean():.2f} / {df.max_eats.mean():.2f}\")\n",
    "    print(f\"Avg Gini (fairness): {df.gini_eats.mean():.3f}\")\n",
    "    deadlock_runs = (df.deadlocks > 0).sum()\n",
    "    print(f\"Deadlock runs: {deadlock_runs}/{len(df)}\")\n",
    "    if deadlock_runs > 0:\n",
    "        first_times = df.loc[df.deadlocks > 0, \"first_deadlock_time\"].dropna()\n",
    "        if len(first_times) > 0:\n",
    "            print(f\"Avg first deadlock time: {first_times.mean():.2f}\")\n",
    "\n",
    "    # Timeout releases nur wenn Spalte existiert (oder strategy timeout)\n",
    "    if \"timeout_releases\" in df.columns:\n",
    "        print(f\"Avg timeout releases/run: {df.timeout_releases.mean():.2f} Â± {df.timeout_releases.std():.2f}\")\n",
    "\n",
    "    # Persistent deadlocks nur fÃ¼r timeout/priority (d.h. nur wenn Spalte existiert)\n",
    "    if \"persistent_deadlocks\" in df.columns:\n",
    "        p_runs = (df.persistent_deadlocks > 0).sum()\n",
    "        print(f\"Persistent-deadlock runs: {p_runs}/{len(df)}\")\n",
    "        if p_runs > 0 and \"first_persistent_deadlock_time\" in df.columns:\n",
    "            p_first = df.loc[df.persistent_deadlocks > 0, \"first_persistent_deadlock_time\"].dropna()\n",
    "            if len(p_first) > 0:\n",
    "                print(f\"Avg first persistent deadlock time: {p_first.mean():.2f}\")\n",
    "\n",
    "    # optional: how many runs had at least one timeout release\n",
    "    # tr_runs = (df.timeout_releases > 0).sum()\n",
    "    # print(f\"Runs with â‰¥1 timeout release: {tr_runs}/{len(df)}\")\n",
    "\n",
    "    eats = np.array(df.eat_counts.to_list())\n",
    "    print(\"Per-philosopher avg eats:\", np.round(eats.mean(axis=0), 2).tolist())\n",
    "    print(\"Per-philosopher std eats:\", np.round(eats.std(axis=0), 2).tolist())\n",
    "    zero_eat_rate = (eats == 0).mean(axis=0)\n",
    "    print(\"Zero-eat rate by philosopher:\", np.round(zero_eat_rate, 3).tolist())\n",
    "    print()\n",
    "\n",
    "\n",
    "# No starvation prevention\n",
    "mc_basic_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=False, prevention_strategy=\"none\", starvation_prevention=False),\n",
    "    runs=50, max_time=120.0, base_seed=5000\n",
    ")\n",
    "\n",
    "mc_detect_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"none\", halt_on_deadlock=True),\n",
    "    runs=50, max_time=120.0, base_seed=5000\n",
    ")\n",
    "\n",
    "mc_priority_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"priority\", starvation_prevention=False),\n",
    "    runs=50, max_time=120.0, base_seed=7000\n",
    ")\n",
    "\n",
    "mc_timeout_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"timeout\",\n",
    "         timeout_duration=2.0, starvation_prevention=False),\n",
    "    runs=50, max_time=120.0, base_seed=8000\n",
    ")\n",
    "\n",
    "# With starvation prevention (FIFO)\n",
    "mc_basic_fifo_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=False, prevention_strategy=\"none\", starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=9000\n",
    ")\n",
    "\n",
    "mc_priority_fifo_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"priority\", starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=10000\n",
    ")\n",
    "\n",
    "mc_timeout_fifo_d = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy=\"timeout\",\n",
    "         timeout_duration=2.0, starvation_prevention=True),\n",
    "    runs=50, max_time=120.0, base_seed=11000\n",
    ")\n",
    "\n",
    "summarize_detailed(mc_basic_d, \"Basic (No Prevention)\")\n",
    "summarize_detailed(mc_basic_fifo_d, \"Basic + FIFO Starvation Prevention\")\n",
    "summarize_detailed(mc_detect_d, \"Detection (Synchronized)\")\n",
    "summarize_detailed(mc_priority_d, \"Priority Ordering\")\n",
    "summarize_detailed(mc_priority_fifo_d, \"Priority + FIFO Starvation Prevention\")\n",
    "summarize_detailed(mc_timeout_d, \"Timeout\")\n",
    "summarize_detailed(mc_timeout_fifo_d, \"Timeout + FIFO Starvation Prevention\")\n",
    "     "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Monte Carlo for 4-Case Comparison"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 237,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Left-First / Randomized (MC) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 47.93 Â± 6.66\n",
      "Avg eats/philosopher: 9.59 Â± 1.33\n",
      "Avg min/max eats: 7.49 / 11.82\n",
      "Avg Gini (fairness): 0.088\n",
      "Deadlock runs: 17/100\n",
      "Avg first deadlock time: 76.99\n",
      "Per-philosopher avg eats: [9.38, 9.61, 9.5, 9.75, 9.69]\n",
      "Per-philosopher std eats: [2.09, 2.36, 2.05, 2.27, 1.89]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Priority / Randomized (MC) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 50.87 Â± 6.28\n",
      "Avg eats/philosopher: 10.17 Â± 1.26\n",
      "Avg min/max eats: 7.89 / 12.81\n",
      "Avg Gini (fairness): 0.095\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [9.21, 9.99, 10.54, 11.43, 9.7]\n",
      "Per-philosopher std eats: [1.83, 2.12, 2.36, 2.21, 2.27]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "mc_lf_random = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='none', synchronized_start=False),\n",
    "    runs=100, max_time=120.0, base_seed=9000\n",
    ")\n",
    "\n",
    "mc_lf_sync = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='none', synchronized_start=True, deadlock_prone=True, halt_on_deadlock=True),\n",
    "    runs=100, max_time=120.0, base_seed=9100\n",
    ")\n",
    "\n",
    "mc_pr_random = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='priority', synchronized_start=False),\n",
    "    runs=100, max_time=120.0, base_seed=9200\n",
    ")\n",
    "\n",
    "mc_pr_sync = run_monte_carlo_detailed(\n",
    "    dict(num_philosophers=5, deadlock_detection=True, prevention_strategy='priority', synchronized_start=True, deadlock_prone=True),\n",
    "    runs=100, max_time=120.0, base_seed=9300\n",
    ")\n",
    "\n",
    "summarize_detailed(mc_lf_random, 'Left-First / Randomized (MC)')\n",
    "# summarize_detailed(mc_lf_sync, 'Left-First / Synchronized (MC)')\n",
    "summarize_detailed(mc_pr_random, 'Priority / Randomized (MC)')\n",
    "# summarize_detailed(mc_pr_sync, 'Priority / Synchronized (MC)')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Task 5\n",
    "\n",
    "General settings:\n",
    "\n",
    "- simulation will be run for 800 time units (= mins), since we will vary the thinking / eating times + increase number of philosophers\n",
    "\n",
    "- this task will be based on the simulation engine including the deadlock prevention rules (= solution to task 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Helper Functions for multiple runs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 238,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ---- 2) Helper: merge dicts (later dicts override earlier ones) ----\n",
    "def merge_cfg(*parts):\n",
    "    cfg = {}\n",
    "    for p in parts:\n",
    "        cfg.update(p)\n",
    "    return cfg\n",
    "\n",
    "# ---- 3) Helper: auto label from cfg ----\n",
    "def cfg_label(cfg, title_prefix=\"\"):\n",
    "    # strategy\n",
    "    s = cfg.get(\"prevention_strategy\", \"none\")\n",
    "    if s == \"none\":\n",
    "        strat = \"Left-First\"\n",
    "    elif s == \"priority\":\n",
    "        strat = \"Priority\"\n",
    "    elif s == \"timeout\":\n",
    "        strat = f\"Timeout(t={cfg.get('timeout_duration', '?')})\"\n",
    "    else:\n",
    "        strat = s\n",
    "\n",
    "    # thinking\n",
    "    if cfg.get(\"unif_thinking_time\", False):\n",
    "        think = f\"Think U({cfg.get('think_unif_low')},{cfg.get('think_unif_high')})\"\n",
    "    else:\n",
    "        think = \"Think Exp(mean=5)\"  # your default\n",
    "\n",
    "    # eating\n",
    "    if cfg.get(\"gauss_eating_time\", False):\n",
    "        eat = f\"Eat N({cfg.get('eat_mean')},{cfg.get('eat_sigma')}) truncated[{cfg.get('eat_gauss_low')},{cfg.get('eat_gauss_high')}]\"\n",
    "    else:\n",
    "        eat = \"Eat Exp(mean=3)\"  # your default\n",
    "\n",
    "    prefix = (title_prefix + \" - \") if title_prefix else \"\"\n",
    "    return f\"{prefix}{strat} - {think} - {eat}\"\n",
    "\n",
    "# ---- 4) One runner for MC + summary ----\n",
    "def run_and_summarize(cfg, runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED, title_prefix=\"\"):\n",
    "    df = run_monte_carlo_detailed(cfg, runs=runs, max_time=max_time, base_seed=base_seed)\n",
    "    summarize_detailed(df, cfg_label(cfg, title_prefix=title_prefix))\n",
    "    return df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inreasing number of philosophers and chopsticks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 239,
   "metadata": {},
   "outputs": [],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 50\n",
    "NUM_PHILS = 10\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 1\n",
    "\n",
    "BASE = dict(\n",
    "    num_philosophers=NUM_PHILS,\n",
    "    deadlock_detection=True,\n",
    ")\n",
    "\n",
    "STRATEGY = {\n",
    "    \"left_first\": dict(prevention_strategy=\"none\"),\n",
    "    \"priority\": dict(prevention_strategy=\"priority\"),\n",
    "    \"timeout\": dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION),\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 255,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Randomized (MC) - Left-First - Think Exp(mean=5) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 529.20 Â± 152.64\n",
      "Avg eats/philosopher: 52.92 Â± 15.26\n",
      "Avg min/max eats: 46.28 / 60.38\n",
      "Avg Gini (fairness): 0.054\n",
      "Deadlock runs: 11/50\n",
      "Avg first deadlock time: 455.17\n",
      "Per-philosopher avg eats: [52.5, 54.06, 51.38, 53.64, 52.9, 53.18, 53.68, 51.98, 53.18, 52.7]\n",
      "Per-philosopher std eats: [15.64, 15.71, 15.27, 15.87, 15.85, 16.13, 15.95, 15.35, 15.73, 15.96]\n",
      "Zero-eat rate by philosopher: [0.02, 0.0, 0.02, 0.0, 0.0, 0.02, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Randomized (MC) - Priority - Think Exp(mean=5) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 650.56 Â± 21.83\n",
      "Avg eats/philosopher: 65.06 Â± 2.18\n",
      "Avg min/max eats: 53.38 / 80.80\n",
      "Avg Gini (fairness): 0.067\n",
      "Deadlock runs: 0/50\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [55.52, 61.58, 61.1, 62.5, 64.74, 65.58, 67.74, 71.22, 80.22, 60.36]\n",
      "Per-philosopher std eats: [5.06, 5.67, 5.65, 6.13, 5.67, 5.7, 5.61, 4.45, 5.89, 4.95]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Randomized (MC) - Timeout(t=1) - Think Exp(mean=5) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 50\n",
      "Avg total eats: 720.42 Â± 20.20\n",
      "Avg eats/philosopher: 72.04 Â± 2.02\n",
      "Avg min/max eats: 63.68 / 81.42\n",
      "Avg Gini (fairness): 0.041\n",
      "Deadlock runs: 0/50\n",
      "Avg timeout releases/run: 552.68 Â± 39.05\n",
      "Persistent-deadlock runs: 0/50\n",
      "Per-philosopher avg eats: [71.82, 71.76, 71.94, 73.16, 72.2, 71.6, 72.7, 71.5, 71.54, 72.2]\n",
      "Per-philosopher std eats: [5.36, 7.19, 5.78, 5.14, 6.05, 4.92, 6.31, 5.81, 5.71, 5.57]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 50\n",
    "NUM_PHILS = 10\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 1\n",
    "\n",
    "BASE = dict(\n",
    "    num_philosophers=NUM_PHILS,\n",
    "    deadlock_detection=True,\n",
    "    halt_on_deadlock=True\n",
    ")\n",
    "\n",
    "# Left-first\n",
    "mc_lf_random_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"none\")),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n",
    "# Priority\n",
    "mc_pr_random_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"priority\")),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n",
    "# Timeout\n",
    "mc_timeout_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I just see 0 deadlocks in the timeout case. i want to look at that in more detail:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 256,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Randomized (MC) - Timeout(t=2) - Think Exp(mean=5) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 354.07 Â± 12.86\n",
      "Avg eats/philosopher: 70.81 Â± 2.57\n",
      "Avg min/max eats: 65.00 / 77.08\n",
      "Avg Gini (fairness): 0.033\n",
      "Deadlock runs: 21/100\n",
      "Avg first deadlock time: 435.97\n",
      "Avg timeout releases/run: 158.92 Â± 15.31\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [69.91, 71.23, 71.32, 70.27, 71.34]\n",
      "Per-philosopher std eats: [4.88, 6.19, 5.17, 4.8, 5.33]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 100\n",
    "NUM_PHILS = 5\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 2\n",
    "\n",
    "BASE = dict(num_philosophers=NUM_PHILS, deadlock_detection=True, halt_on_deadlock= True)\n",
    "\n",
    "mc_timeout_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "so we see that with the same settings just with num_phils = 5, we apparently got deadlocks. \n",
    "\n",
    "So maybe the explanation is that with 10 philosophers, getting into a deadlock is much more unlikely than for 5 philosophers? \n",
    "\n",
    "Let's try it with less than 5 philosophers:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 257,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Randomized (MC) - Timeout(t=2) - Think Exp(mean=5) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 211.42 Â± 11.39\n",
      "Avg eats/philosopher: 70.47 Â± 3.80\n",
      "Avg min/max eats: 66.00 / 74.91\n",
      "Avg Gini (fairness): 0.028\n",
      "Deadlock runs: 95/100\n",
      "Avg first deadlock time: 230.50\n",
      "Avg timeout releases/run: 113.93 Â± 13.66\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [70.55, 70.8, 70.07]\n",
      "Per-philosopher std eats: [5.75, 5.43, 5.98]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 100\n",
    "NUM_PHILS = 3\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 2\n",
    "\n",
    "BASE = dict(num_philosophers=NUM_PHILS, deadlock_detection=True)\n",
    "\n",
    "mc_timeout_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Okay so with 3 phils, we see that we got a lot more deadlocks. So, it apparently is much more likely in this case that we have the deadlock conditions to get true\n",
    "\n",
    "So I think for this reason, I will rather look at 5 philosophers, to ensure that deadlock chances are higher"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Variability in thinking time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 258,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Randomized (MC) - Left-First - Think U(2.0,30.0) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 194.42 Â± 7.29\n",
      "Avg eats/philosopher: 38.88 Â± 1.46\n",
      "Avg min/max eats: 35.93 / 41.97\n",
      "Avg Gini (fairness): 0.030\n",
      "Deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [38.83, 38.84, 39.03, 38.91, 38.81]\n",
      "Per-philosopher std eats: [2.55, 2.86, 3.07, 2.9, 2.49]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Randomized (MC) - Priority - Think U(2.0,30.0) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 193.66 Â± 7.56\n",
      "Avg eats/philosopher: 38.73 Â± 1.51\n",
      "Avg min/max eats: 35.37 / 42.02\n",
      "Avg Gini (fairness): 0.033\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [38.15, 38.7, 38.8, 39.16, 38.85]\n",
      "Per-philosopher std eats: [2.88, 3.0, 2.86, 2.68, 3.26]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Randomized (MC) - Left-First - Think U(2.0,4.0) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 265.92 Â± 19.10\n",
      "Avg eats/philosopher: 53.18 Â± 3.82\n",
      "Avg min/max eats: 51.93 / 54.53\n",
      "Avg Gini (fairness): 0.010\n",
      "Deadlock runs: 2/100\n",
      "Avg first deadlock time: 3.55\n",
      "Per-philosopher avg eats: [53.2, 53.0, 53.35, 53.2, 53.17]\n",
      "Per-philosopher std eats: [4.02, 4.08, 4.09, 3.83, 3.72]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Randomized (MC) - Priority - Think U(2.0,4.0) - Eat Exp(mean=3) (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 372.84 Â± 19.75\n",
      "Avg eats/philosopher: 74.57 Â± 3.95\n",
      "Avg min/max eats: 61.67 / 95.07\n",
      "Avg Gini (fairness): 0.091\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [61.85, 72.5, 80.57, 95.07, 62.85]\n",
      "Per-philosopher std eats: [4.52, 4.18, 4.56, 5.6, 4.48]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 100\n",
    "NUM_PHILS = 5\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 2\n",
    "\n",
    "BASE = dict(num_philosophers=NUM_PHILS, deadlock_detection=True)\n",
    "\n",
    "THINK_2_30 = dict(unif_thinking_time=True, think_unif_low=2.0, think_unif_high=30.0)\n",
    "THINK_2_4  = dict(unif_thinking_time=True, think_unif_low=2.0, think_unif_high=4.0)\n",
    "\n",
    "# Left-first, think U(2,30)\n",
    "mc_lf_5 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"none\"), THINK_2_30),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n",
    "# Priority, think U(2,30)\n",
    "mc_lf_5_4 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"priority\"), THINK_2_30),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n",
    "# Left-first, think U(2,4)\n",
    "mc_lf_5_2 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"none\"), THINK_2_4),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")\n",
    "\n",
    "# Priority, think U(2,4)\n",
    "mc_lf_5_3 = run_and_summarize(\n",
    "    merge_cfg(BASE, dict(prevention_strategy=\"priority\"), THINK_2_4),\n",
    "    runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED,\n",
    "    title_prefix=\"Randomized (MC)\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "we see the impact of the thinking time. if the thinking time duration is higher, then the deadlock chances are lower. i will also change the distribution for the eating times.\n",
    "\n",
    "we also see here, the inequality in the priority increases with the number of philosophers / changing times"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Variability in eating time"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Conclusion:\n",
    "\n",
    "Setting thinking_time~unif(2,4) is just too much time for thinking. in this case, we have nearly 0 deadlock cases, so not that interesting. \n",
    "\n",
    "For this reason, I set thinking_time~unif(0.3,3), eating_time i will maybe alternate."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 259,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Left-First - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 99.53 Â± 3.94\n",
      "Avg eats/philosopher: 19.91 Â± 0.79\n",
      "Avg min/max eats: 19.36 / 20.38\n",
      "Avg Gini (fairness): 0.010\n",
      "Deadlock runs: 36/100\n",
      "Avg first deadlock time: 377.01\n",
      "Per-philosopher avg eats: [20.01, 19.87, 19.82, 19.89, 19.94]\n",
      "Per-philosopher std eats: [0.93, 0.89, 0.85, 0.89, 0.97]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Priority - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 175.80 Â± 4.72\n",
      "Avg eats/philosopher: 35.16 Â± 0.94\n",
      "Avg min/max eats: 29.17 / 45.66\n",
      "Avg Gini (fairness): 0.092\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [29.46, 33.61, 37.47, 45.66, 29.6]\n",
      "Per-philosopher std eats: [1.75, 1.34, 1.47, 2.51, 1.67]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Timeout(t=8) - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 158.47 Â± 6.07\n",
      "Avg eats/philosopher: 31.69 Â± 1.21\n",
      "Avg min/max eats: 28.72 / 34.55\n",
      "Avg Gini (fairness): 0.035\n",
      "Deadlock runs: 16/100\n",
      "Avg first deadlock time: 347.86\n",
      "Avg timeout releases/run: 80.81 Â± 9.91\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [31.87, 31.45, 31.44, 31.44, 32.27]\n",
      "Per-philosopher std eats: [2.24, 2.59, 2.46, 2.66, 2.44]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Left-First - Think U(0.3,3.0) - Eat N(15.0,3.0) truncated[1.0,30.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 55.77 Â± 4.77\n",
      "Avg eats/philosopher: 11.15 Â± 0.95\n",
      "Avg min/max eats: 10.65 / 11.63\n",
      "Avg Gini (fairness): 0.018\n",
      "Deadlock runs: 26/100\n",
      "Avg first deadlock time: 390.77\n",
      "Per-philosopher avg eats: [11.23, 11.17, 11.12, 11.11, 11.14]\n",
      "Per-philosopher std eats: [1.01, 1.14, 1.04, 1.09, 0.97]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Priority - Think U(0.3,3.0) - Eat N(15.0,3.0) truncated[1.0,30.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 99.24 Â± 3.53\n",
      "Avg eats/philosopher: 19.85 Â± 0.71\n",
      "Avg min/max eats: 17.12 / 24.28\n",
      "Avg Gini (fairness): 0.072\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [17.4, 19.23, 20.94, 24.27, 17.4]\n",
      "Per-philosopher std eats: [1.6, 1.11, 1.05, 1.6, 1.47]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n",
      "=== Timeout(t=15) - Think U(0.3,3.0) - Eat N(15.0,3.0) truncated[1.0,30.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 88.55 Â± 5.01\n",
      "Avg eats/philosopher: 17.71 Â± 1.00\n",
      "Avg min/max eats: 15.51 / 19.85\n",
      "Avg Gini (fairness): 0.049\n",
      "Deadlock runs: 4/100\n",
      "Avg first deadlock time: 440.59\n",
      "Avg timeout releases/run: 39.42 Â± 10.08\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [17.81, 17.53, 17.86, 17.47, 17.88]\n",
      "Per-philosopher std eats: [1.96, 1.89, 2.03, 2.14, 1.87]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 100\n",
    "NUM_PHILS = 5\n",
    "SEED = 9000\n",
    "TIMEOUT_DURATION = 2\n",
    "\n",
    "BASE = dict(\n",
    "    num_philosophers=NUM_PHILS,\n",
    "    deadlock_detection=True,\n",
    ")\n",
    "\n",
    "THINKING = {\n",
    "    \"unif_2_30\": dict(unif_thinking_time=True, think_unif_low=2.0, think_unif_high=30.0),\n",
    "    \"unif_0_3_3\": dict(unif_thinking_time=True, think_unif_low=0.3, think_unif_high=3.0),\n",
    "}\n",
    "\n",
    "EATING = {\n",
    "    \"gauss_8_3_1_16\": dict(gauss_eating_time=True, eat_mean=8.0, eat_sigma=3.0, eat_gauss_low=1.0, eat_gauss_high=16.0),\n",
    "    \"gauss_15_3_1_30\": dict(gauss_eating_time=True, eat_mean=15.0, eat_sigma=3.0, eat_gauss_low=1.0, eat_gauss_high=30.0),\n",
    "}\n",
    "\n",
    "STRATEGY = {\n",
    "    \"left_first\": dict(prevention_strategy=\"none\"),\n",
    "    \"priority\": dict(prevention_strategy=\"priority\"),\n",
    "    \"timeout\": dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION),\n",
    "}\n",
    "\n",
    "# looking at gauss_8_3_1_16 \n",
    "\n",
    "mc3 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"left_first\"], THINKING[\"unif_0_3_3\"], EATING[\"gauss_8_3_1_16\"]))\n",
    "mc4 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"priority\"],   THINKING[\"unif_0_3_3\"], EATING[\"gauss_8_3_1_16\"]))\n",
    "TIMEOUT_DURATION = 8\n",
    "STRATEGY[\"timeout\"] = dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)\n",
    "mc5 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"timeout\"],   THINKING[\"unif_0_3_3\"], EATING[\"gauss_8_3_1_16\"]))\n",
    "\n",
    "# looking at gauss_15_3_1_30\n",
    "\n",
    "mc3 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"left_first\"], THINKING[\"unif_0_3_3\"], EATING[\"gauss_15_3_1_30\"]))\n",
    "mc4 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"priority\"],   THINKING[\"unif_0_3_3\"], EATING[\"gauss_15_3_1_30\"]))\n",
    "TIMEOUT_DURATION = 15\n",
    "STRATEGY[\"timeout\"] = dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)\n",
    "mc5 = run_and_summarize(merge_cfg(BASE, STRATEGY[\"timeout\"],   THINKING[\"unif_0_3_3\"], EATING[\"gauss_15_3_1_30\"]))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "the results seem legit, except for the thing with the deadlocks with the timeout strategy: gpt says, normyll with the timeout stratefy, we expect 0 deadlocks, but maybe it is beacuse of our implementation, where the deadlock just occurs for a short while, and then gets solved by the timeout strategy, but is still counted. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Selfish Philosophers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Ideas for Selfish philosophers:\n",
    "    - Ignores timeout and still holds chopsticks\n",
    "    - Ignores priority ordering -> just takes left or right chopstick first randomly\n",
    "    - Does not drop chopsticks directly after eating"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I will just use the following base configs of the model:\n",
    "\n",
    "- 5 Philosophers, Max_time = 800, MC runs = 100\n",
    "- thinking time: unif(0.3, 3)\n",
    "- eating time: norm(8, 3) (truncated: [1, 16]) \n",
    "- prevention strategy: lower chopstick id or timeout, will depend on actual case (f.e. ignoring timeout just possible for timeout strategy)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 0. Baselines"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Baseline for lower chopstick id strategy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 260,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Baseline - Priority - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 175.80 Â± 4.72\n",
      "Avg eats/philosopher: 35.16 Â± 0.94\n",
      "Avg min/max eats: 29.17 / 45.66\n",
      "Avg Gini (fairness): 0.092\n",
      "Deadlock runs: 0/100\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [29.46, 33.61, 37.47, 45.66, 29.6]\n",
      "Per-philosopher std eats: [1.75, 1.34, 1.47, 2.51, 1.67]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "MAX_TIME = 800\n",
    "MC_RUNS = 100\n",
    "NUM_PHILS = 5\n",
    "SEED = 9000\n",
    "\n",
    "BASE_COMMON = dict(\n",
    "    num_philosophers=NUM_PHILS,\n",
    "    deadlock_detection=True,\n",
    "    halt_on_deadlock = True,\n",
    "\n",
    "    # thinking: U(0.3, 3)\n",
    "    unif_thinking_time=True,\n",
    "    think_unif_low=0.3,\n",
    "    think_unif_high=3.0,\n",
    "\n",
    "    # eating: N(8,3) truncated to [1,16]\n",
    "    gauss_eating_time=True,\n",
    "    eat_mean=8.0,\n",
    "    eat_sigma=3.0,\n",
    "    eat_gauss_low=1.0,\n",
    "    eat_gauss_high=16.0,\n",
    ")\n",
    "\n",
    "# Baseline 1: Priority (lower ID first)\n",
    "cfg_priority = merge_cfg(\n",
    "    BASE_COMMON,\n",
    "    dict(prevention_strategy=\"priority\")\n",
    ")\n",
    "df_priority = run_and_summarize(cfg_priority, runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED, title_prefix=\"Baseline\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Baseline for timeout strategy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 254,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Baseline - Timeout(t=8) - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 158.47 Â± 6.07\n",
      "Avg eats/philosopher: 31.69 Â± 1.21\n",
      "Avg min/max eats: 28.72 / 34.55\n",
      "Avg Gini (fairness): 0.035\n",
      "Deadlock runs: 16/100\n",
      "Avg first deadlock time: 347.86\n",
      "Avg timeout releases/run: 80.81 Â± 9.91\n",
      "Persistent-deadlock runs: 0/100\n",
      "Per-philosopher avg eats: [31.87, 31.45, 31.44, 31.44, 32.27]\n",
      "Per-philosopher std eats: [2.24, 2.59, 2.46, 2.66, 2.44]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "TIMEOUT_DURATION = 8  # aligned with eat_mean=8\n",
    "\n",
    "# Baseline 2: Timeout\n",
    "cfg_timeout = merge_cfg(\n",
    "    BASE_COMMON,\n",
    "    dict(prevention_strategy=\"timeout\", timeout_duration=TIMEOUT_DURATION)\n",
    ")\n",
    "df_timeout = run_and_summarize(cfg_timeout, runs=MC_RUNS, max_time=MAX_TIME, base_seed=SEED, title_prefix=\"Baseline\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1 Selfish Philosopher: Ignoring timeout + Not dropping after eating\n",
    "\n",
    "Selfish Philosopher does the following:\n",
    "- Ignores timeout and still holds chopsticks\n",
    "- Does not drop chopsticks directly after eating"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== Baseline - Timeout(t=8) - Think U(0.3,3.0) - Eat N(8.0,3.0) truncated[1.0,16.0] (Detailed) ===\n",
      "Runs: 100\n",
      "Avg total eats: 159.03 Â± 5.74\n",
      "Avg eats/philosopher: 31.81 Â± 1.15\n",
      "Avg min/max eats: 28.94 / 34.55\n",
      "Avg Gini (fairness): 0.034\n",
      "Deadlock runs: 16/100\n",
      "Avg first deadlock time: 347.86\n",
      "Avg timeout releases/run: 79.85 Â± 9.36\n",
      "Per-philosopher avg eats: [32.14, 31.4, 31.63, 31.74, 32.12]\n",
      "Per-philosopher std eats: [2.22, 2.57, 2.34, 2.4, 2.42]\n",
      "Zero-eat rate by philosopher: [0.0, 0.0, 0.0, 0.0, 0.0]\n",
      "\n"
     ]
    }
   ],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2 Selfish Philosophers: Ignoring timeout + Not dropping after eating\n",
    "\n",
    "They do the same as in the case with 1 selfish philoopher"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1 Selfish Philosopher: Ignoring priority ordering + Not dropping after eating\n",
    "\n",
    "Selfish Philosopher does the following:\n",
    "- Ignores timeout and still holds chopstick\n",
    "- Does not drop chopsticks immediately after eating"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2 Selfish Philosophers: Ignoring priority ordering + Not dropping after eating\n",
    "They do the same as in the case with 1 selfish philoopher"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conspiracies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 199,
   "metadata": {},
   "outputs": [],
   "source": [
    "# todo"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
